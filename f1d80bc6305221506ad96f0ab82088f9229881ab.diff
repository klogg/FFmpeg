diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/cmdutils.c /home/klogg/Downloads/ffmpeg-plex/cmdutils.c
--- FFmpeg-Plex-Transcoder/cmdutils.c	2017-05-16 15:47:03.654792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/cmdutils.c	2017-05-04 13:47:00.000000000 +0300
@@ -884,6 +884,12 @@
     int level;
     int flags;
     int i;
+//PLEX
+    typedef void (*av_log_set_level_fn)(int);
+    av_log_set_level_fn set_level_fn = (av_log_set_level_fn) optctx;
+    if (!set_level_fn)
+        set_level_fn = &av_log_set_level;
+//PLEX
 
     flags = av_log_get_flags();
     tail = strstr(arg, "repeat");
@@ -900,7 +906,7 @@
 
     for (i = 0; i < FF_ARRAY_ELEMS(log_levels); i++) {
         if (!strcmp(log_levels[i].name, arg)) {
-            av_log_set_level(log_levels[i].level);
+            set_level_fn(log_levels[i].level); //PLEX
             return 0;
         }
     }
@@ -913,7 +919,7 @@
             av_log(NULL, AV_LOG_FATAL, "\"%s\"\n", log_levels[i].name);
         exit_program(1);
     }
-    av_log_set_level(level);
+    set_level_fn(level); //PLEX
     return 0;
 }
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/common.mak /home/klogg/Downloads/ffmpeg-plex/common.mak
--- FFmpeg-Plex-Transcoder/common.mak	2017-05-16 16:04:37.734792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/common.mak	2017-05-04 13:47:00.000000000 +0300
@@ -109,6 +109,7 @@
 include $(SRC_PATH)/arch.mak
 
 OBJS      += $(OBJS-yes)
+OBJS      += $(OBJS-$(NAME))
 SLIBOBJS  += $(SLIBOBJS-yes)
 FFLIBS    := $($(NAME)_FFLIBS) $(FFLIBS-yes) $(FFLIBS)
 TESTPROGS += $(TESTPROGS-yes)
@@ -161,6 +162,18 @@
 DISTCLEANSUFFIXES = *.pc
 LIBSUFFIXES       = *.a *.lib *.so *.so.* *.dylib *.dll *.def *.dll.a
 
+define RM_SPLIT
+	$(eval _splitargs:=)
+	$(foreach obj,$1,$(eval _splitargs+=$(wildcard $(obj))))
+	$(eval _args:=)
+	$(foreach obj,$(_splitargs),$(eval _args+=$(obj))$(if $(word 20,$(_args)),$(RM)$(_args)$(EOL)$(eval _args:=)))
+	$(if $(_args),$(RM)$(_args))
+endef
+define EOL
+
+
+endef
+
 define RULES
 clean::
 	$(RM) $(HOSTPROGS) $(TESTPROGS) $(TOOLS)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/configure /home/klogg/Downloads/ffmpeg-plex/configure
--- FFmpeg-Plex-Transcoder/configure	2017-05-16 16:07:56.050792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/configure	2017-05-04 13:47:00.000000000 +0300
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # FFmpeg configure script
 #
@@ -204,6 +204,7 @@
   --enable-avisynth        enable reading of AviSynth script files [no]
   --disable-bzlib          disable bzlib [autodetect]
   --enable-chromaprint     enable audio fingerprinting with chromaprint [no]
+  --disable-eae            disable EAE [yes]
   --enable-frei0r          enable frei0r video filtering [no]
   --enable-gcrypt          enable gcrypt, needed for rtmp(t)e support
                            if openssl, librtmp or gmp is not used [no]
@@ -280,6 +281,8 @@
   --disable-lzma           disable lzma [autodetect]
   --enable-decklink        enable Blackmagic DeckLink I/O support [no]
   --enable-mediacodec      enable Android MediaCodec support [no]
+  --enable-mediacodecndk   enable native Android MediaCodec support [no]
+  --enable-mf              enable decoding via MediaFoundation [no]
   --enable-netcdf          enable NetCDF, needed for sofalizer filter [no]
   --enable-openal          enable OpenAL 1.1 capture support [no]
   --enable-opencl          enable OpenCL code
@@ -607,6 +610,10 @@
     set_all yes $*
 }
 
+external(){
+    set_all external $*
+}
+
 disable(){
     set_all no $*
 }
@@ -631,31 +638,54 @@
     done
 }
 
-do_enable_deep(){
+do_enable_dep(){
+    enable_fn=$1
+    shift 1
+    enable_type=yes
+    [ "$check_phase" = external ] && enable_type=external
+    for var in $*; do
+        if ! enabled $var ; then
+            $enable_fn $enable_type $var
+        fi
+    done
+}
+
+enable_dep(){
+    do_enable_dep set_all $*
+}
+
+enable_dep_weak(){
+    do_enable_dep set_weak $*
+}
+
+do_enable_dep_deep(){
     for var; do
         enabled $var && continue
         eval sel="\$${var}_select"
         eval sgs="\$${var}_suggest"
         pushvar var sgs
-        enable_deep $sel
+        enable_dep_deep $sel
         popvar sgs
-        enable_deep_weak $sgs
+        enable_dep_deep_weak $sgs
         popvar var
+        for dep in $sel $sgs; do
+            eval "${dep}_dependents=\"\${${dep}_dependents} $var\""
+        done
     done
 }
 
-enable_deep(){
-    do_enable_deep $*
-    enable $*
+enable_dep_deep(){
+    do_enable_dep_deep $*
+    enable_dep $*
 }
 
-enable_deep_weak(){
+enable_dep_deep_weak(){
     for var; do
         disabled $var && continue
         pushvar var
-        do_enable_deep $var
+        do_enable_dep_deep $var
         popvar var
-        enable_weak $var
+        enable_dep_weak $var
     done
 }
 
@@ -666,9 +696,20 @@
 
 enabled(){
     test "${1#!}" = "$1" && op='=' || op=!=
+    test "${1#!}" = "$1" && op2='||' || op2='&&'
+    eval test "x\$${1#!}" $op "xyes" $op2 eval test "x\$${1#!}" $op "xexternal"
+}
+
+enabled_not_external(){
+    test "${1#!}" = "$1" && op='=' || op=!=
     eval test "x\$${1#!}" $op "xyes"
 }
 
+is_external(){
+    test "${1#!}" = "$1" && op='=' || op=!=
+    eval test "x\$${1#!}" $op "xexternal"
+}
+
 disabled(){
     test "${1#!}" = "$1" && op='=' || op=!=
     eval test "x\$${1#!}" $op "xno"
@@ -714,9 +755,23 @@
     return 1
 }
 
+# First enable normal deps. After this, in a second pass, enable externals.
+# Components not enabled yet in the externals pass are also marked as externals.
+#
+# If normal deps depend on externals, we'll get errors at link time. But we
+# don't want such cases anyway.
+#
+# Multiple externals can depend on the same external deps. Each external DSO
+# will have a copy of the components' code.
+
 do_check_deps(){
     for cfg; do
         cfg="${cfg#!}"
+        if [ "$check_phase" = external ] ; then
+            is_external $cfg || continue
+        else
+            is_external $cfg && continue
+        fi
         enabled ${cfg}_checking && die "Circular dependency for $cfg."
         disabled ${cfg}_checking && continue
         enable ${cfg}_checking
@@ -733,25 +788,73 @@
         do_check_deps $dep_all $dep_any $dep_sel $dep_sgs $dep_ifa $dep_ifn
         popvar cfg dep_all dep_any dep_sel dep_sgs dep_ifa dep_ifn
 
-        [ -n "$dep_ifa" ] && { enabled_all $dep_ifa && enable_weak $cfg; }
-        [ -n "$dep_ifn" ] && { enabled_any $dep_ifn && enable_weak $cfg; }
+        [ -n "$dep_ifa" ] && { enabled_all $dep_ifa && enable_dep_weak $cfg; }
+        [ -n "$dep_ifn" ] && { enabled_any $dep_ifn && enable_dep_weak $cfg; }
         enabled_all  $dep_all || { disable $cfg && requested $cfg && die "ERROR: $cfg requested, but not all dependencies are satisfied: $dep_all"; }
         enabled_any  $dep_any || { disable $cfg && requested $cfg && die "ERROR: $cfg requested, but not any dependency is satisfied: $dep_any"; }
         disabled_any $dep_sel && { disable $cfg && requested $cfg && die "ERROR: $cfg requested, but some selected dependency is unsatisfied: $dep_sel"; }
 
         if enabled $cfg; then
-            enable_deep $dep_sel
-            enable_deep_weak $dep_sgs
+            enable_dep_deep $dep_sel
+            enable_dep_deep_weak $dep_sgs
+            for dep in $dep_sel $dep_sgs; do
+                eval "${dep}_dependents=\"\${${dep}_dependents} $cfg\""
+            done
         fi
 
         disable ${cfg}_checking
     done
 }
 
+collect_deps(){
+    for var in $all_deps ; do
+        [ x"$cfg" = x"$var" ] && return
+    done
+
+    if enabled ${cfg} ; then
+        [ x"$root_dep" != x"$cfg" ] && all_deps="$all_deps $cfg"
+        eval dep_sel="\$${cfg}_select"
+        eval dep_sgs="\$${cfg}_suggest"
+
+        for var in $dep_sel $dep_sgs ; do
+            pushvar var cfg dep_sel dep_sgs
+            cfg=$var
+            collect_deps
+            popvar var cfg dep_sel dep_sgs
+        done
+    fi
+}
+
 check_deps(){
     unset allopts
 
+    check_level=0
+    check_phase=
+    do_check_deps "$@"
+    check_phase=external
     do_check_deps "$@"
+    check_phase=
+
+    for cfg in $allopts; do
+        all_deps=
+        root_dep=$cfg
+        collect_deps $cfg
+        eval "${cfg}_deplist=\"\$all_deps\""
+        if is_external $cfg ; then
+            deplist_mak=
+            for dep in $all_deps ; do
+                is_external $dep && deplist_mak="$deplist_mak \$(OBJS-$dep)"
+            done
+            eval "${cfg}_deplist_mak=\"\$deplist_mak\""
+        fi
+        if enabled_not_external $cfg ; then
+            for dep in $all_deps ; do
+                if is_external $dep ; then
+                    eval "${cfg}_dependents=\"\$${cfg}_dependents avcodec\""
+                fi
+            done
+        fi
+    done
 
     for cfg in $allopts; do
         enabled $cfg || continue
@@ -764,22 +867,55 @@
     pfx=$1
     files=$2
     shift 2
-    map 'eval echo "$v \${$v:-no}"' "$@" |
+    map 'eval echo "$v \${$v:-no} \${${v}_dependents}"' "$@" |
     awk "BEGIN { split(\"$files\", files) }
         {
             c = \"$pfx\" toupper(\$1);
             v = \$2;
+            sub(/external/, 2, v);
             sub(/yes/, 1, v);
             sub(/no/,  0, v);
             for (f in files) {
                 file = files[f];
                 if (file ~ /\\.h\$/) {
+                    if (v == 2) {
+                        c2 = toupper(\$1);
+                        printf(\"#if defined(BUILDING_%s_EXTERNAL)\", c2) >>file;
+                        for (i = 3; i <= NF; i++)
+                            printf(\" || defined(BUILDING_%s_EXTERNAL)\", toupper(\$i)) >>file;
+                        printf(\"\n\") >>file;
+                        printf(\"#define %s 1\\n\", c) >>file;
+                        printf(\"#else\\n\") >>file;
+                        printf(\"#define %s 0\\n\", c) >>file;
+                        printf(\"#endif\\n\") >>file;
+                    } else {
                     printf(\"#define %s %d\\n\", c, v) >>file;
+                    }
                 } else if (file ~ /\\.asm\$/) {
+                    if (v == 2) {
+                        c2 = toupper(\$1);
+                        printf(\"%%ifdef BUILDING_%s_EXTERNAL\\n\", c2) >>file;
+                        printf(\"%%define %s 1\\n\", c) >>file;
+                        for (i = 3; i <= NF; i++) {
+                            printf(\"%%elifdef BUILDING_%s_EXTERNAL\\n\", toupper(\$i)) >>file;
+                            printf(\"%%define %s 1\\n\", c) >>file;
+                        }
+                        printf(\"%%else\\n\") >>file;
+                        printf(\"%%define %s 0\\n\", c) >>file;
+                        printf(\"%%endif\\n\") >>file;
+                    } else {
                     printf(\"%%define %s %d\\n\", c, v) >>file;
+                    }
                 } else if (file ~ /\\.mak\$/) {
                     n = -v ? \"\" : \"!\";
-                    printf(\"%s%s=yes\\n\", n, c) >>file;
+                    e = (v == 2) ? \$1 : \"yes\";
+                    printf(\"%s%s=%s\\n\", n, c, e) >>file;
+                    n = (v == 2) ? \"\" : \"!\";
+                    printf(\"%s%s_EXTERNAL=yes\\n\", n, c) >>file;
+                    if (v == 2)
+                        printf(\"EXTERNALS+=%s\\n\", e) >>file;
+                    for (i = 3; i <= NF; i++)
+                        printf(\"OBJS-%s+=\$(OBJS-%s)\\n\", \$i, \$1) >>file;
                 } else if (file ~ /\\.texi\$/) {
                     pre = -v ? \"\" : \"@c \";
                     yesno = \$2;
@@ -795,7 +931,9 @@
     suf=$1
     shift
     for v; do
-        enabled $v && printf "%s\n" ${v%$suf}
+        extsuf=""
+        is_external $v && extsuf="(ext)"
+        enabled $v && printf "%s%s\n" ${v%$suf} ${extsuf}
     done
 }
 
@@ -1537,6 +1675,7 @@
     chromaprint
     crystalhd
     decklink
+    eae
     gcrypt
     gnutls
     jni
@@ -1585,6 +1724,8 @@
     libzmq
     libzvbi
     mediacodec
+    mediacodecndk
+    mf
     netcdf
     openal
     opencl
@@ -2090,6 +2231,7 @@
     cabac
     dirac_parse
     dvprofile
+    eae
     exif
     faandct
     faanidct
@@ -2126,6 +2268,7 @@
     lpc
     lzf
     me_cmp
+    mf
     mpeg_er
     mpegaudio
     mpegaudiodsp
@@ -2350,10 +2493,10 @@
 mdct15_select="fft"
 me_cmp_select="fdctdsp idctdsp pixblockdsp"
 mpeg_er_select="error_resilience"
-mpegaudio_select="mpegaudiodsp mpegaudioheader"
+mpegaudio_select="mpegaudiodsp mdct mpegaudioheader"
 mpegaudiodsp_select="dct"
 mpegvideo_select="blockdsp h264chroma hpeldsp idctdsp me_cmp mpeg_er videodsp"
-mpegvideoenc_select="me_cmp mpegvideo pixblockdsp qpeldsp"
+mpegvideoenc_select="me_cmp mpegvideo pixblockdsp qpeldsp aandcttables"
 vc1dsp_select="h264chroma qpeldsp startcode"
 rdft_select="fft"
 
@@ -2362,7 +2505,7 @@
 aac_fixed_decoder_select="mdct sinewin"
 aac_encoder_select="audio_frame_queue iirfilter lpc mdct sinewin"
 aac_latm_decoder_select="aac_decoder aac_latm_parser"
-ac3_decoder_select="ac3_parser ac3dsp bswapdsp fmtconvert mdct"
+ac3_decoder_select="ac3_parser ac3dsp bswapdsp fmtconvert mdct fft"
 ac3_fixed_decoder_select="ac3_parser ac3dsp bswapdsp mdct"
 ac3_encoder_select="ac3dsp audiodsp mdct me_cmp"
 ac3_fixed_encoder_select="ac3dsp audiodsp mdct me_cmp"
@@ -2585,6 +2728,8 @@
 # platform codecs
 audiotoolbox_deps="AudioToolbox_AudioToolbox_h"
 audiotoolbox_extralibs="-framework CoreFoundation -framework AudioToolbox -framework CoreMedia"
+mf_deps="mftransform_h"
+mf_extralibs="-lmfplat -lole32 -lstrmiids -luuid -loleaut32 -lshlwapi"
 
 # hardware accelerators
 crystalhd_deps="libcrystalhd_libcrystalhd_if_h"
@@ -2614,6 +2759,7 @@
 h264_dxva2_hwaccel_deps="dxva2"
 h264_dxva2_hwaccel_select="h264_decoder"
 h264_mediacodec_hwaccel_deps="mediacodec"
+h264_mf_hwaccel_deps="mf"
 h264_mmal_hwaccel_deps="mmal"
 h264_qsv_hwaccel_deps="libmfx"
 h264_vaapi_hwaccel_deps="vaapi"
@@ -2634,11 +2780,13 @@
 hevc_dxva2_hwaccel_deps="dxva2 DXVA_PicParams_HEVC"
 hevc_dxva2_hwaccel_select="hevc_decoder"
 hevc_qsv_hwaccel_deps="libmfx"
+hevc_mf_hwaccel_deps="mf"
 hevc_vaapi_hwaccel_deps="vaapi VAPictureParameterBufferHEVC"
 hevc_vaapi_hwaccel_select="hevc_decoder"
 hevc_vdpau_hwaccel_deps="vdpau VdpPictureInfoHEVC"
 hevc_vdpau_hwaccel_select="hevc_decoder"
 mjpeg_cuvid_hwaccel_deps="cuda cuvid"
+mjpeg_mf_hwaccel_deps="mf"
 mjpeg_cuvid_hwaccel_select="mjpeg_cuvid_decoder"
 mpeg_xvmc_hwaccel_deps="xvmc"
 mpeg_xvmc_hwaccel_select="mpeg2video_decoder"
@@ -2656,6 +2804,7 @@
 mpeg2_d3d11va_hwaccel_select="mpeg2video_decoder"
 mpeg2_dxva2_hwaccel_deps="dxva2"
 mpeg2_dxva2_hwaccel_select="mpeg2video_decoder"
+mpeg2_mf_hwaccel_deps="mf"
 mpeg2_mmal_hwaccel_deps="mmal"
 mpeg2_qsv_hwaccel_deps="libmfx"
 mpeg2_qsv_hwaccel_select="qsvdec_mpeg2"
@@ -2670,6 +2819,7 @@
 mpeg4_cuvid_hwaccel_deps="cuda cuvid"
 mpeg4_cuvid_hwaccel_select="mpeg4_cuvid_decoder"
 mpeg4_mediacodec_hwaccel_deps="mediacodec"
+mpeg4_mf_hwaccel_deps="mf"
 mpeg4_mmal_hwaccel_deps="mmal"
 mpeg4_vaapi_hwaccel_deps="vaapi"
 mpeg4_vaapi_hwaccel_select="mpeg4_decoder"
@@ -2677,12 +2827,18 @@
 mpeg4_vdpau_hwaccel_select="mpeg4_decoder"
 mpeg4_videotoolbox_hwaccel_deps="videotoolbox"
 mpeg4_videotoolbox_hwaccel_select="mpeg4_decoder"
+
+msmpeg4v1_mf_hwaccel_deps="mf"
+msmpeg4v2_mf_hwaccel_deps="mf"
+msmpeg4v3_mf_hwaccel_deps="mf"
+
 vc1_cuvid_hwaccel_deps="cuda cuvid"
 vc1_cuvid_hwaccel_select="vc1_cuvid_decoder"
 vc1_d3d11va_hwaccel_deps="d3d11va"
 vc1_d3d11va_hwaccel_select="vc1_decoder"
 vc1_dxva2_hwaccel_deps="dxva2"
 vc1_dxva2_hwaccel_select="vc1_decoder"
+vc1_mf_hwaccel_deps="mf"
 vc1_mmal_hwaccel_deps="mmal"
 vc1_qsv_hwaccel_deps="libmfx"
 vc1_qsv_hwaccel_select="qsvdec_vc1"
@@ -2703,8 +2859,11 @@
 vp9_mediacodec_hwaccel_deps="mediacodec"
 vp9_vaapi_hwaccel_deps="vaapi VADecPictureParameterBufferVP9_bit_depth"
 vp9_vaapi_hwaccel_select="vp9_decoder"
+wmv1_mf_hwaccel_deps="mf"
+wmv2_mf_hwaccel_deps="mf"
 wmv3_d3d11va_hwaccel_select="vc1_d3d11va_hwaccel"
 wmv3_dxva2_hwaccel_select="vc1_dxva2_hwaccel"
+wmv3_mf_hwaccel_deps="mf"
 wmv3_vaapi_hwaccel_select="vc1_vaapi_hwaccel"
 wmv3_vdpau_hwaccel_select="vc1_vdpau_hwaccel"
 
@@ -2801,7 +2960,6 @@
 mpegaudio_parser_select="mpegaudioheader"
 mpegvideo_parser_select="mpegvideo"
 mpeg4video_parser_select="h263dsp mpegvideo qpeldsp"
-vc1_parser_select="vc1dsp"
 
 # bitstream_filters
 mjpeg2jpeg_bsf_select="jpegtables"
@@ -2841,6 +2999,13 @@
 pcm_mulaw_at_encoder_deps="audiotoolbox"
 pcm_mulaw_at_encoder_select="audio_frame_queue"
 chromaprint_muxer_deps="chromaprint"
+eae_select="ac3_parser mlp_parser"
+ac3_eae_decoder_select="eae"
+ac3_eae_encoder_select="eae"
+eac3_eae_decoder_select="eae"
+eac3_eae_encoder_select="eae"
+truehd_eae_decoder_select="eae"
+mlp_eae_decoder_select="eae"
 h264_videotoolbox_encoder_deps="videotoolbox_encoder pthreads"
 libcelt_decoder_deps="libcelt"
 libfdk_aac_decoder_deps="libfdk_aac"
@@ -2899,6 +3064,38 @@
 libxavs_encoder_deps="libxavs"
 libxvid_encoder_deps="libxvid"
 libzvbi_teletext_decoder_deps="libzvbi"
+aac_mf_decoder_deps="mf"
+aac_mf_encoder_deps="mf"
+ac3_mf_decoder_deps="mf"
+ac3_mf_encoder_deps="mf"
+eac3_mf_decoder_deps="mf"
+h264_mf_decoder_deps="mf"
+h264_mf_encoder_deps="mf"
+hevc_mf_decoder_deps="mf"
+hevc_mf_encoder_deps="mf"
+mjpeg_mf_decoder_deps="mf"
+mp1_mf_decoder_deps="mf"
+mp2_mf_decoder_deps="mf"
+mp3_mf_decoder_deps="mf"
+mp3_mf_encoder_deps="mf"
+mpeg2_mf_decoder_deps="mf"
+mpeg4_mf_decoder_deps="mf"
+msmpeg4v1_mf_decoder_deps="mf"
+msmpeg4v2_mf_decoder_deps="mf"
+msmpeg4v3_mf_decoder_deps="mf"
+vc1_mf_decoder_deps="mf"
+wmav1_mf_decoder_deps="mf"
+wmav2_mf_decoder_deps="mf"
+wmalossless_mf_decoder_deps="mf"
+wmapro_mf_decoder_deps="mf"
+wmavoice_mf_decoder_deps="mf"
+wmv1_mf_decoder_deps="mf"
+wmv2_mf_decoder_deps="mf"
+wmv3_mf_decoder_deps="mf"
+h264_mediacodecndk_decoder_deps="mediacodecndk"
+h264_mediacodecndk_encoder_deps="mediacodecndk"
+hevc_mediacodecndk_decoder_deps="mediacodecndk"
+mpeg2_mediacodecndk_decoder_deps="mediacodecndk"
 videotoolbox_deps="VideoToolbox_VideoToolbox_h"
 videotoolbox_extralibs="-framework CoreFoundation -framework VideoToolbox -framework CoreMedia -framework CoreVideo"
 videotoolbox_encoder_deps="videotoolbox VTCompressionSessionPrepareToEncodeFrames"
@@ -3176,6 +3373,8 @@
 zscale_filter_deps="libzimg"
 scale_vaapi_filter_deps="vaapi VAProcPipelineParameterBuffer"
 
+inlineass_filter_deps="avcodec libass"
+
 # examples
 avio_dir_cmd_deps="avformat avutil"
 avio_reading_deps="avformat avcodec avutil"
@@ -3489,7 +3688,7 @@
             action=${opt%%-random=*}
             do_random ${action#--} $optval
         ;;
-        --enable-*=*|--disable-*=*)
+        --enable-*=*|--disable-*=*|--external-*=*)
             eval $(echo "${opt%%=*}" | sed 's/--/action=/;s/-/ thing=/')
             is_in "${thing}s" $COMPONENT_LIST || die_unknown "$opt"
             eval list=\$$(toupper $thing)_LIST
@@ -3546,7 +3745,7 @@
 done
 
 # Enable platform codecs by default.
-enable_weak audiotoolbox
+enable_weak audiotoolbox mf
 
 # Enable hwaccels by default.
 enable_weak d3d11va dxva2 vaapi vda vdpau videotoolbox_hwaccel xvmc
@@ -3554,8 +3753,35 @@
 
 enable_weak cuda cuvid nvenc vda_framework videotoolbox videotoolbox_encoder
 
+# Always available at compile time (just not runtime)
+enable eae
+
 disabled logging && logfile=/dev/null
 
+# Fix hwaccel autodetection
+for cfg in $HWACCEL_LIST ; do
+    if enabled $cfg ; then
+        parent_full=${cfg/%_hwaccel/_decoder}
+        parent_main=${cfg/_*/_decoder}
+        if ! is_in $parent_full $DECODER_LIST ; then
+            if ! is_in $parent_main $DECODER_LIST ; then
+                parent_main=${cfg/_*/video_decoder}
+            fi
+            if is_external $parent_main ; then
+                external $cfg
+                # void the dependency from hwaccel to decoder, we're going to do
+                # it the other way around
+                eval sel="\$${cfg}_select"
+                sel=${sel/${parent_main}/}
+                eval ${cfg}_select="\${sel}"
+            elif ! enabled_not_external $parent_main ; then
+                echo "disable."
+                disable $cfg
+            fi
+        fi
+    fi
+done
+
 die_license_disabled() {
     enabled $1 || { enabled $v && die "$v is $1 and --enable-$1 is not specified."; }
 }
@@ -5483,6 +5709,16 @@
 check_code cc arm_neon.h "int16x8_t test = vdupq_n_s16(0)" && enable intrinsics_neon
 
 check_ldflags -Wl,--as-needed
+check_cflags "-fdata-sections -ffunction-sections"
+if [ "x$target_os" = "xdarwin" ]; then
+    check_ldflags -Wl,-dead_strip
+elif [ "x$target_os" = "xmingw32" ]; then
+    LINKPREFIX=_
+    enabled x86_64 && LINKPREFIX=
+    EXTLIBFLAGS="-Wl,--gc-sections -Wl,--require-defined=${LINKPREFIX}av_init_library"
+else
+    check_ldflags -Wl,--gc-sections
+fi
 check_ldflags -Wl,-z,noexecstack
 
 if check_func dlopen && check_func dlsym; then
@@ -5626,6 +5862,7 @@
 check_header libcrystalhd/libcrystalhd_if.h
 check_header mach/mach_time.h
 check_header malloc.h
+check_header mftransform.h
 check_header net/udplite.h
 check_header poll.h
 check_header sys/mman.h
@@ -5871,6 +6108,7 @@
                              { check_cpp_condition libzvbi.h "VBI_VERSION_MAJOR > 0 || VBI_VERSION_MINOR > 2 || VBI_VERSION_MINOR == 2 && VBI_VERSION_MICRO >= 28" ||
                                enabled gpl || die "ERROR: libzvbi requires version 0.2.28 or --enable-gpl."; }
 enabled mediacodec        && { enabled jni || die "ERROR: mediacodec requires --enable-jni"; }
+enabled mediacodecndk     && require mediacodec media/NdkMediaCodec.h AMediaCodec_createDecoderByType -lmediandk
 enabled mmal              && { check_lib interface/mmal/mmal.h mmal_port_connect -lmmal_core -lmmal_util -lmmal_vc_client -lbcm_host ||
                                { ! enabled cross_compile &&
                                  add_cflags -isystem/opt/vc/include/ -isystem/opt/vc/include/interface/vmcs_host/linux -isystem/opt/vc/include/interface/vcos/pthreads -fgnu89-inline &&
@@ -6390,6 +6628,27 @@
     prepend ffmpeg_libs $($ldflags_filter "-lole32") &&
     enable dxva2_lib
 
+# Merge hwaccels with their proper decoder.
+for cfg in $HWACCEL_LIST ; do
+    if enabled $cfg ; then
+        parent_full=${cfg/%_hwaccel/_decoder}
+        parent_main=${cfg/_*/_decoder}
+        if ! is_in $parent_full $DECODER_LIST ; then
+            if ! is_in $parent_main $DECODER_LIST ; then
+                parent_main=${cfg/_*/video_decoder}
+            fi
+            if is_external $parent_main ; then
+                external $cfg
+                eval ${parent_main}_hwaccels="\"\$${parent_main}_hwaccels ${cfg}\""
+                eval deps="\$${parent_main}_dependents"
+                deps=${deps/${cfg}/}
+                eval ${parent_main}_dependents="\${deps}"
+                eval ${cfg}_dependents="\"\$${cfg}_dependents ${parent_main}\""
+            fi
+        fi
+    fi
+done
+
 # add_dep lib dep
 # -> enable ${lib}_deps_${dep}
 # -> add $dep to ${lib}_deps only once
@@ -6606,13 +6865,33 @@
 print_enabled '' $PROGRAM_LIST | print_in_columns
 echo
 
-for type in decoder encoder hwaccel parser demuxer muxer protocol filter bsf indev outdev; do
+componenttypes="decoder encoder hwaccel parser demuxer muxer protocol filter bsf indev outdev"
+
+for type in $componenttypes; do
     echo "Enabled ${type}s:"
     eval list=\$$(toupper $type)_LIST
     print_enabled '_*' $list | print_in_columns
     echo
 done
 
+echo "External components and deps:"
+
+for cfg in $allopts; do
+    is_external $cfg || continue
+    for componenttype in $componenttypes ; do
+        if echo $cfg | grep -q $componenttype ; then
+            printf "%s" "$cfg:"
+            eval deplist="\$${cfg}_deplist"
+            for dep in $deplist ; do
+                add="(internal)"
+                is_external $dep && add=""
+                printf "%s" " $dep$add"
+            done
+            printf "\n"
+        fi
+    done
+done
+
 echo "License: $license"
 
 echo "Creating configuration files ..."
@@ -6692,6 +6971,7 @@
 LDEXEFLAGS=$LDEXEFLAGS
 LDLIBFLAGS=$LDLIBFLAGS
 SHFLAGS=$(echo $($ldflags_filter $SHFLAGS))
+EXTLIBFLAGS=$(echo $($ldflags_filter $EXTLIBFLAGS))
 ASMSTRIPFLAGS=$ASMSTRIPFLAGS
 YASMFLAGS=$YASMFLAGS
 BUILDSUF=$build_suffix
@@ -6818,6 +7098,49 @@
                                      $CONFIG_EXTRA      \
                                      $ALL_COMPONENTS    \
 
+EXT_OBJS_LIST="
+    armv5te
+    armv6
+    armv8
+    vfp
+    neon
+    mmx
+    yasm
+"
+
+# Add dependencies for external components to config.mak
+for cfg in $CONFIG_LIST       \
+           $CONFIG_EXTRA      \
+           $HAVE_LIST         \
+           $ALL_COMPONENTS    \
+; do
+    cfg="${cfg#!}"
+    disabled ${cfg} && continue
+    eval deplist="\$${cfg}_deplist_mak"
+    if [ -n "$deplist" ] ; then
+        echo "OBJS-$cfg += $deplist" >> config.mak
+    fi
+    if is_external $cfg ; then
+        # arch.mak fixups
+        for ext in $EXT_OBJS_LIST; do
+            if enabled $ext; then
+                echo "OBJS-$cfg += \$($(toupper $ext)-OBJS-${cfg})" >> config.mak
+            fi
+        done
+        # used for extlib_init.c
+        eval cfg_hwaccels="\$${cfg}_hwaccels"
+        ok_hwaccels=""
+        for hwaccel in $cfg_hwaccels ; do
+            if is_external $hwaccel ; then
+                ok_hwaccels="$ok_hwaccels $hwaccel"
+                echo "OBJS-$cfg += \$(OBJS-$hwaccel)" >> config.mak
+            fi
+        done
+        hwaccel_list=$(echo $ok_hwaccels|sed -E "s/[^ ][A-Za-z0-9_]*/ff_&, /g"|sed -E "s/ +/ /g")
+        echo "HWACCELS-$cfg = ${hwaccel_list}" >> config.mak
+    fi
+done
+
 echo "#endif /* FFMPEG_CONFIG_H */" >> $TMPH
 echo "endif # FFMPEG_CONFIG_MAK" >> config.mak
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/ffmpeg.c /home/klogg/Downloads/ffmpeg-plex/ffmpeg.c
--- FFmpeg-Plex-Transcoder/ffmpeg.c	2017-05-16 15:47:33.754792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/ffmpeg.c	2017-05-04 13:47:00.000000000 +0300
@@ -109,6 +109,10 @@
 
 #include "libavutil/avassert.h"
 
+//PLEX
+#include "plex.h"
+//PLEX
+
 const char program_name[] = "ffmpeg";
 const int program_birth_year = 2000;
 
@@ -257,8 +261,10 @@
     }
     dst          = frame->data    [0];
     dst_linesize = frame->linesize[0];
+
     for (i = 0; i < num_rects; i++)
         sub2video_copy_rect(dst, dst_linesize, frame->width, frame->height, sub->rects[i]);
+
     sub2video_push_ref(ist, pts);
     ist->sub2video.end_pts = end_pts;
 }
@@ -1018,6 +1024,7 @@
         pkt.size = subtitle_out_size;
         pkt.pts  = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->mux_timebase);
         pkt.duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->mux_timebase);
+        pkt.flags |= AV_PKT_FLAG_KEY; //PLEX
         if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {
             /* XXX: the pts correction is handled here. Maybe handling
                it in the codec would be better */
@@ -1659,9 +1666,12 @@
     int hours, mins, secs, us;
     int ret;
     float t;
-
-    if (!print_stats && !is_last_report && !progress_avio)
+//PLEX
+    static int64_t run_time = 0;
+    static int64_t start_time = 0;
+    if (!print_stats && !is_last_report && !progress_avio && !plexContext.progress_url) //PLEX
         return;
+//PLEX
 
     if (!is_last_report) {
         if (last_time == -1) {
@@ -1670,7 +1680,14 @@
         }
         if ((cur_time - last_time) < 500000)
             return;
+
+//PLEX
+       run_time = cur_time-last_time;
         last_time = cur_time;
+
+       if (start_time == 0)
+           start_time = cur_time;
+//PLEX
     }
 
     t = (cur_time-timer_start) / 1000000.0;
@@ -1758,6 +1775,84 @@
             nb_frames_drop += ost->last_dropped;
     }
 
+//PLEX
+    if (pts != AV_NOPTS_VALUE) {
+        static int64_t last_pts = 0;
+        static int lastRemaining = 0;
+        // Notify about progress.
+        int64_t secs = pts / AV_TIME_BASE;
+        int64_t totalSecs = (input_files && input_files[0] && input_files[0]->ctx->duration != AV_NOPTS_VALUE)
+                          ? input_files[0]->ctx->duration / AV_TIME_BASE
+                          : 0;
+        char url[4096];
+
+        if (plexContext.progress_url) {
+            char* reply;
+            int hw_state = -1;
+            // Compute speed of transcode as a multiple of real-time.
+            float speed = (float)(pts - last_pts) / (float)run_time;
+            // Compute estimated time remaining.
+            int remainingSecs = (totalSecs - secs) / speed;
+            int smoothedRemaining = remainingSecs;
+            if (lastRemaining != 0)
+                smoothedRemaining = lastRemaining*0.5 + remainingSecs*0.5;
+
+            // Sanity check.
+            if (smoothedRemaining < 0)
+                smoothedRemaining = -1;
+            // Only pass back speed if we're not throttled.
+
+            snprintf(url, sizeof(url),
+                    "%s?progress=%.1f&size=%lld&remaining=%d&vdec_packets=%d",
+                    plexContext.progress_url, totalSecs == 0 ? -1 : (float)secs*100.0/totalSecs,
+                    (long long)total_size, smoothedRemaining, plexContext.packets_in);
+
+            if (plexContext.hwaccel_failed)
+                av_strlcatf(url, sizeof(url), "&vdec_hw_failed=%d", plexContext.hwaccel_failed);
+            if (plexContext.sw_failed)
+                av_strlcatf(url, sizeof(url), "&vdec_sw_failed=%d", plexContext.sw_failed);
+            if (plexContext.hwaccel_succeeded)
+                av_strlcatf(url, sizeof(url), "&vdec_hw_ok=%d", plexContext.hwaccel_succeeded);
+            if (plexContext.sw_succeeded)
+                av_strlcatf(url, sizeof(url), "&vdec_sw_ok=%d", plexContext.sw_succeeded);
+
+            if (plexContext.throttle_delay == 0)
+                av_strlcatf(url, sizeof(url), "&speed=%.1f", speed);
+
+            for (i = 0; i < nb_input_streams; i++) {
+                InputStream *ist = input_streams[i];
+                // As long as all video streams (that are decoded) use hw decoding,
+                // signal that hw decoding is used.
+                if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&
+                    ist->decoding_needed &&
+                    ist->frames_decoded)
+                    hw_state = (hw_state < 0 || hw_state == 1) && ist->hwaccel_active;
+            }
+            if (hw_state >= 0)
+                av_strlcatf(url, sizeof(url), "&vdec_hw_status=%d", hw_state);
+
+            reply = PMS_IssueHttpRequest(url, "PUT");
+
+            // Handle throttling.
+            if (strstr(reply, "canThrottle")) {
+                if (plexContext.throttle_delay == 0)
+                    PMS_Log(LOG_LEVEL_DEBUG, "Throttle - Going into sloth mode.");
+
+                plexContext.throttle_delay = 100;
+            } else {
+                if (plexContext.throttle_delay == 100)
+                    PMS_Log(LOG_LEVEL_DEBUG, "Throttle - Getting back to work.");
+
+                plexContext.throttle_delay = 0;
+            }
+
+            av_free(reply);
+            lastRemaining = remainingSecs;
+        }
+        last_pts = pts;
+    }
+//PLEX
+
     secs = FFABS(pts) / AV_TIME_BASE;
     us = FFABS(pts) % AV_TIME_BASE;
     mins = secs / 60;
@@ -2168,6 +2263,9 @@
 
     /* (re)init the graph if possible, otherwise buffer the frame and return */
     if (need_reinit || !fg->graph) {
+        for (i = 0; i < nb_input_streams; i++)
+            input_streams[i]->sub2video.end_pts = 0;
+
         for (i = 0; i < fg->nb_inputs; i++) {
             if (!ifilter_has_all_input_formats(fg)) {
                 AVFrame *tmp = av_frame_clone(frame);
@@ -2394,6 +2492,11 @@
         ist->dts_buffer[ist->nb_dts_buffer++] = dts;
     }
 
+//PLEX
+    if (pkt && pkt->size)
+        plexContext.packets_in++;
+//PLEX
+
     update_benchmark(NULL);
     ret = decode(ist->dec_ctx, decoded_frame, got_output, pkt ? &avpkt : NULL);
     update_benchmark("decode_video %d.%d", ist->file_index, ist->st->index);
@@ -2418,6 +2521,42 @@
     if (ret != AVERROR_EOF)
         check_decode_result(ist, got_output, ret);
 
+//PLEX
+    // We want to increment the frame count if:
+    // - there was an error
+    // - a frame was output
+    // But never when we have reached EOF, or output was skipped.
+    if (ret != AVERROR_EOF && (ret < 0 || *got_output)) {
+        int is_hwaccel = ist->hwaccel_active;
+        if (*got_output) {
+            const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(decoded_frame->format);
+            is_hwaccel = pixdesc && (pixdesc->flags & AV_PIX_FMT_FLAG_HWACCEL);
+        }
+        if (ret < 0) {
+            if (is_hwaccel) {
+                plexContext.hwaccel_failed++;
+                ist->hwaccel_error_counter++;
+                if (ist->hwaccel_fallback_threshold &&
+                    ist->hwaccel_error_counter >= ist->hwaccel_fallback_threshold) {
+                    ist->hwaccel_active = 0;
+                    ist->hwaccel_blocked = 1;
+                    av_log(ist->dec_ctx, AV_LOG_WARNING,
+                           "Triggering violent fallback to software decoding!\n");
+                    avcodec_flush_buffers(ist->dec_ctx);
+                }
+            } else {
+                plexContext.sw_failed++;
+            }
+        } else {
+            if (is_hwaccel) {
+                plexContext.hwaccel_succeeded++;
+            } else {
+                plexContext.sw_succeeded++;
+            }
+        }
+    }
+//PLEX
+
     if (*got_output && ret >= 0) {
         if (ist->dec_ctx->width  != decoded_frame->width ||
             ist->dec_ctx->height != decoded_frame->height ||
@@ -2531,7 +2670,9 @@
 
     if (ist->sub2video.frame) {
         sub2video_update(ist, &subtitle);
-    } else if (ist->nb_filters) {
+    } else if (ist->nb_filters
+               || plex_process_subtitles(ist, &subtitle) == 1 //PLEX
+               ) {
         if (!ist->sub2video.sub_queue)
             ist->sub2video.sub_queue = av_fifo_alloc(8 * sizeof(AVSubtitle));
         if (!ist->sub2video.sub_queue)
@@ -2809,6 +2950,8 @@
     const enum AVPixelFormat *p;
     int ret;
 
+    ist->hwaccel_active = 0;
+
     for (p = pix_fmts; *p != -1; p++) {
         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(*p);
         const HWAccel *hwaccel;
@@ -2816,6 +2959,9 @@
         if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL))
             break;
 
+        if (ist->hwaccel_blocked)
+            continue;
+
         hwaccel = get_hwaccel(*p);
         if (!hwaccel ||
             (ist->active_hwaccel_id && ist->active_hwaccel_id != hwaccel->id) ||
@@ -2829,7 +2975,6 @@
                        "%s hwaccel requested for input stream #%d:%d, "
                        "but cannot be initialized.\n", hwaccel->name,
                        ist->file_index, ist->st->index);
-                return AV_PIX_FMT_NONE;
             }
             continue;
         }
@@ -2837,11 +2982,12 @@
         if (ist->hw_frames_ctx) {
             s->hw_frames_ctx = av_buffer_ref(ist->hw_frames_ctx);
             if (!s->hw_frames_ctx)
-                return AV_PIX_FMT_NONE;
+                continue;
         }
 
         ist->active_hwaccel_id = hwaccel->id;
         ist->hwaccel_pix_fmt   = *p;
+        ist->hwaccel_active    = 1;
         break;
     }
 
@@ -3674,6 +3820,22 @@
     for (i = 0; i < nb_output_streams; i++) {
         ost = output_streams[i];
 
+//PLEX
+        AVCodecContext* codec = ost->st->codec;
+        if (codec && codec->codec_type == AVMEDIA_TYPE_VIDEO && codec->width && plexContext.progress_url) {
+            // Compute real width/height based on storage aspect ratio.
+            char url[1024];
+            char* reply;
+            int width = codec->width;
+            if (codec->sample_aspect_ratio.num && codec->sample_aspect_ratio.den)
+                width = av_rescale(width, codec->sample_aspect_ratio.num, codec->sample_aspect_ratio.den);
+
+            snprintf(url, sizeof(url), "%s?width=%d&height=%d", plexContext.progress_url, width, codec->height);
+            reply = PMS_IssueHttpRequest(url, "PUT");
+            av_free(reply);
+        }
+//PLEX
+
         if (ost->attachment_filename) {
             /* an attached file */
             av_log(NULL, AV_LOG_INFO, "  File %s -> Stream #%d:%d\n",
@@ -4389,6 +4551,12 @@
 
     process_input_packet(ist, &pkt, 0);
 
+//PLEX
+    // Delay if needed.
+    if (plexContext.throttle_delay > 0)
+      usleep(1000*plexContext.throttle_delay);
+//PLEX
+
 discard_packet:
     av_packet_unref(&pkt);
 
@@ -4523,6 +4691,24 @@
     int64_t timer_start;
     int64_t total_packets_written = 0;
 
+//PLEX
+    for (i = 0; i < nb_output_files; i++) {
+        AVFormatContext* ctx_input = (input_files && input_files[0]) ? input_files[0]->ctx : NULL;
+        AVFormatContext* ctx_output = output_files[i]->ctx;
+        char str[128];
+
+        if (ctx_input && ctx_input->duration != AV_NOPTS_VALUE &&
+            (!strcmp(ctx_output->oformat->name, "matroska") ||
+             !strcmp(ctx_output->oformat->name, "segment"))) {
+            int64_t start_time = input_files[0]->start_time != AV_NOPTS_VALUE ?
+                                 input_files[0]->start_time : 0;
+            // Duration of the part we're transcoding.
+            sprintf(str, "%g", (ctx_input->duration - (copy_ts ? 0 : start_time)) / (double)AV_TIME_BASE);
+            av_dict_set(&ctx_output->metadata, "duration", str, 0);
+        }
+    }
+//PLEX
+
     ret = transcode_init();
     if (ret < 0)
         goto fail;
@@ -4719,6 +4905,9 @@
         argv++;
     }
 
+    // PLEX: Setup log callback
+    plex_init();
+
     avcodec_register_all();
 #if CONFIG_AVDEVICE
     avdevice_register_all();
@@ -4751,6 +4940,8 @@
 //         exit_program(1);
 //     }
 
+    plex_feedback((input_files && input_files[0]) ? input_files[0]->ctx : NULL); //PLEX
+
     for (i = 0; i < nb_output_files; i++) {
         if (strcmp(output_files[i]->ctx->oformat->name, "rtp"))
             want_sdp = 0;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/ffmpeg_filter.c /home/klogg/Downloads/ffmpeg-plex/ffmpeg_filter.c
--- FFmpeg-Plex-Transcoder/ffmpeg_filter.c	2017-05-16 15:47:03.690792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/ffmpeg_filter.c	2017-05-04 13:47:00.000000000 +0300
@@ -39,6 +39,10 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/samplefmt.h"
 
+//PLEX
+#include "plex.h"
+//PLEX
+
 static const enum AVPixelFormat *get_compliance_unofficial_pix_fmts(enum AVCodecID codec_id, const enum AVPixelFormat default_formats[])
 {
     static const enum AVPixelFormat mjpeg_formats[] =
@@ -759,6 +763,13 @@
     if(!sar.den)
         sar = (AVRational){0,1};
     av_bprint_init(&args, 0, 1);
+    // PLEX
+    // If we run out of time in the analysis probe, the pixel format might
+    // not be detected correctly. This sets a sane default if that happens,
+    // which is probably good >75% of the time, which is better than 0%.
+    if (ifilter->format == AV_PIX_FMT_NONE)
+        ifilter->format = AV_PIX_FMT_YUV420P;
+    // PLEX
     av_bprintf(&args,
              "video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:"
              "pixel_aspect=%d/%d:sws_param=flags=%d",
@@ -852,6 +863,11 @@
     char name[255];
     int ret, pad_idx = 0;
     int64_t tsoffset = 0;
+//PLEX
+    // remove once we strictly use a format from decoded frames
+    if (ifilter->format == AV_SAMPLE_FMT_NONE)
+        ifilter->format = AV_SAMPLE_FMT_S16P;
+//PLEX
 
     if (ist->dec_ctx->codec_type != AVMEDIA_TYPE_AUDIO) {
         av_log(NULL, AV_LOG_ERROR, "Cannot connect audio filter to non audio input\n");
@@ -1093,6 +1109,11 @@
         ofilter->channel_layout = av_buffersink_get_channel_layout(sink);
     }
 
+//PLEX
+    //make sure the inlineasscontext is set up properly for each stream
+    plex_link_subtitles_to_graph(fg->graph);
+//PLEX
+
     fg->reconfiguration = 1;
 
     for (i = 0; i < fg->nb_outputs; i++) {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/ffmpeg.h /home/klogg/Downloads/ffmpeg-plex/ffmpeg.h
--- FFmpeg-Plex-Transcoder/ffmpeg.h	2017-05-16 15:47:03.690792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/ffmpeg.h	2017-05-04 13:47:00.000000000 +0300
@@ -67,6 +67,7 @@
     HWACCEL_QSV,
     HWACCEL_VAAPI,
     HWACCEL_CUVID,
+    HWACCEL_MF,
 };
 
 typedef struct HWAccel {
@@ -226,6 +227,10 @@
     int        nb_program;
     SpecifierOpt *time_bases;
     int        nb_time_bases;
+
+    // PLEX
+    SpecifierOpt *hwaccel_fallback_thresholds;
+    int        nb_hwaccel_fallback_thresholds;
 } OptionsContext;
 
 typedef struct InputFilter {
@@ -384,6 +389,12 @@
     int nb_dts_buffer;
 
     int got_output;
+
+    // PLEX
+    int hwaccel_active;             // whether hwdec was initialized
+    int hwaccel_blocked;            // if set, don't try to use hwaccel
+    int hwaccel_error_counter;      // current error counter for fallback
+    int hwaccel_fallback_threshold; // after how many errors to start fallback
 } InputStream;
 
 typedef struct InputFile {
@@ -657,5 +668,6 @@
 int vaapi_decode_init(AVCodecContext *avctx);
 int vaapi_device_init(const char *device);
 int cuvid_init(AVCodecContext *s);
+int mf_init(AVCodecContext *s);
 
 #endif /* FFMPEG_H */
Only in /home/klogg/Downloads/ffmpeg-plex/: ffmpeg_mf.c
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/ffmpeg_opt.c /home/klogg/Downloads/ffmpeg-plex/ffmpeg_opt.c
--- FFmpeg-Plex-Transcoder/ffmpeg_opt.c	2017-05-16 15:47:03.690792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/ffmpeg_opt.c	2017-05-04 13:47:00.000000000 +0300
@@ -43,6 +43,10 @@
 
 #define DEFAULT_PASS_LOGFILENAME_PREFIX "ffmpeg2pass"
 
+//PLEX
+#include "plex.h"
+//PLEX
+
 #define MATCH_PER_STREAM_OPT(name, type, outvar, fmtctx, st)\
 {\
     int i, ret;\
@@ -87,6 +91,9 @@
 #if CONFIG_CUVID
     { "cuvid", cuvid_init, HWACCEL_CUVID, AV_PIX_FMT_CUDA },
 #endif
+#if CONFIG_MF
+    { "mf",    mf_init,    HWACCEL_MF,    AV_PIX_FMT_MF },
+#endif
     { 0 },
 };
 int hwaccel_lax_profile_check = 0;
@@ -624,7 +631,7 @@
         av_log(NULL, AV_LOG_FATAL, "Unknown %s '%s'\n", codec_string, name);
         exit_program(1);
     }
-    if (codec->type != type) {
+    if (codec->type != type && type != AVMEDIA_TYPE_UNKNOWN) {
         av_log(NULL, AV_LOG_FATAL, "Invalid %s type '%s'\n", codec_string, name);
         exit_program(1);
     }
@@ -639,6 +646,7 @@
     if (codec_name) {
         AVCodec *codec = find_codec_or_die(codec_name, st->codecpar->codec_type, 0);
         st->codecpar->codec_id = codec->id;
+        st->codecpar->codec_type = codec->type;
         return codec;
     } else
         return avcodec_find_decoder(st->codecpar->codec_id);
@@ -656,6 +664,7 @@
         InputStream *ist = av_mallocz(sizeof(*ist));
         char *framerate = NULL, *hwaccel = NULL, *hwaccel_device = NULL;
         char *hwaccel_output_format = NULL;
+        int hwaccel_force_fallback = 0;
         char *codec_tag = NULL;
         char *next;
         char *discard_str = NULL;
@@ -795,6 +804,9 @@
 
             ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;
 
+            MATCH_PER_STREAM_OPT(hwaccel_fallback_thresholds, str,
+                                 ist->hwaccel_fallback_threshold, ic, st);
+
             break;
         case AVMEDIA_TYPE_AUDIO:
             ist->guess_layout_max = INT_MAX;
@@ -1000,6 +1012,11 @@
     remove_avoptions(&o->g->format_opts, o->g->codec_opts);
     assert_avoptions(o->g->format_opts);
 
+//PLEX
+    for (i = 0; i < ic->nb_streams; i++)
+        plex_report_stream(ic->streams[i]);
+//PLEX
+
     /* apply forced codec ids */
     for (i = 0; i < ic->nb_streams; i++)
         choose_decoder(o, ic, ic->streams[i]);
@@ -1011,6 +1028,31 @@
     /* If not enough info to get the stream parameters, we decode the
        first frames to get it. (used in mpeg case for example) */
     ret = avformat_find_stream_info(ic, opts);
+//PLEX
+
+    int repeat_find_stream_info = ic->nb_streams > orig_nb_streams;
+    for (i = 0; i < ic->nb_streams; i++) {
+        if (i > orig_nb_streams || ic->streams[i]->request_probe == -1) // -1 indicates the codec was probed
+            plex_report_stream(ic->streams[i]);
+
+        if (ic->streams[i]->info)
+            memset(ic->streams[i]->info, 0, sizeof(*ic->streams[i]->info));
+    }
+
+    if (repeat_find_stream_info) {
+        for (i = orig_nb_streams; i < ic->nb_streams; i++)
+            choose_decoder(o, ic, ic->streams[i]);
+        for (i = 0; i < orig_nb_streams; i++)
+            av_dict_free(&opts[i]);
+        av_freep(&opts);
+        opts = setup_find_stream_info_opts(ic, o->g->codec_opts);
+        orig_nb_streams = ic->nb_streams;
+        ret = avformat_find_stream_info(ic, opts);
+    }
+
+    for (i = 0; i < ic->nb_streams; i++)
+        plex_report_stream_detail(ic->streams[i]);
+//PLEX
     if (ret < 0) {
         av_log(NULL, AV_LOG_FATAL, "%s: could not find codec parameters\n", filename);
         if (ic->nb_streams == 0) {
@@ -1705,6 +1747,44 @@
     if (ost->stream_copy)
         check_streamcopy_filters(o, oc, ost, AVMEDIA_TYPE_VIDEO);
 
+//PLEX
+    if (source_index >= 0 && 0)
+    {
+      // See if things are sane.
+      long int averageFPS = 0;
+      if (input_streams[source_index]->st->avg_frame_rate.den != 0)
+        averageFPS = (int)(av_q2d(input_streams[source_index]->st->avg_frame_rate)+0.5);
+
+      long int framerateFPS = 0;
+      if (input_streams[source_index]->st->r_frame_rate.den != 0)
+        framerateFPS = (int)(av_q2d(input_streams[source_index]->st->r_frame_rate)+0.5);
+
+      PMS_Log(LOG_LEVEL_DEBUG, "Average FPS ~ %d fps, Frame rate ~ %d fps.", averageFPS, framerateFPS);
+
+      // Don't trust any super high framerates. But if a frame rate was specified, just use that.
+      if (!frame_rate && averageFPS != 0 && framerateFPS != 0 && labs(averageFPS - framerateFPS) > 10)
+      {
+        AVStream* st = input_streams[source_index]->st;
+
+        PMS_Log(LOG_LEVEL_DEBUG, "Codec frame rate differs from container rate, attempting to fix.");
+
+        if (st->avg_frame_rate.den != 0)
+        {
+          ost->frame_rate.num = st->avg_frame_rate.num;
+          ost->frame_rate.den = st->avg_frame_rate.den;
+          PMS_Log(LOG_LEVEL_DEBUG, "Forcing fps to frame rate of %f.", av_q2d(st->avg_frame_rate));
+        }
+
+        if (st->avg_frame_rate.den == 0 || av_q2d(st->avg_frame_rate) > 150.0)
+        {
+          ost->frame_rate.num = st->r_frame_rate.num;
+          ost->frame_rate.den = st->r_frame_rate.den;
+          PMS_Log(LOG_LEVEL_DEBUG, "Forcing fps to frame rate of %f.", av_q2d(st->r_frame_rate));
+        }
+      }
+    }
+//PLEX
+
     return ost;
 }
 
@@ -2104,6 +2184,17 @@
         }
     }
 
+//PLEX
+        /* we need to detect the format of the subtitle stream (if any) and init
+         some stuff before we do the actual pre set-up */
+        for (i = 0; i < nb_input_streams; i++)
+            plex_prepare_setup_streams_for_input_stream(input_streams[i]);
+
+        /* we need to choose the subtitle stream we want to burn in
+         (needs to be processed BEFORE the video stream is set up
+         as this call will configer the vfilters) */
+//PLEX
+
     if (!strcmp(file_oformat->name, "ffm") && !override_ffserver &&
         av_strstart(filename, "http:", NULL)) {
         int j;
@@ -2155,9 +2246,13 @@
                     idx = i;
                 }
             }
-            if (idx >= 0)
+//PLEX
+            if (idx >= 0) {
+                plex_link_input_stream(input_streams[idx]);
                 new_video_stream(o, oc, idx);
         }
+//PLEX
+        }
 
         /* audio: most channels */
         if (!o->audio_disable && av_guess_codec(oc->oformat, NULL, filename, NULL, AVMEDIA_TYPE_AUDIO) != AV_CODEC_ID_NONE) {
@@ -2225,6 +2320,10 @@
                 OutputFilter *ofilter = NULL;
                 int j, k;
 
+//PLEX
+                plex_link_input_stream(input_streams[input_files[map->file_index]->ist_index + map->stream_index]);
+//PLEX
+
                 for (j = 0; j < nb_filtergraphs; j++) {
                     fg = filtergraphs[j];
                     for (k = 0; k < fg->nb_outputs; k++) {
@@ -2255,6 +2354,8 @@
                 if(o->    data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA)
                     continue;
 
+                plex_link_input_stream(ist); //PLEX
+
                 ost = NULL;
                 switch (ist->st->codecpar->codec_type) {
                 case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;
@@ -3663,5 +3764,14 @@
         "set QSV hardware device (DirectX adapter index, DRM path or X11 display name)", "device"},
 #endif
 
+//PLEX
+    { "map_inlineass", HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT, { .func_arg = plex_opt_subtitle_stream }, "index of the subtitle stream to burn into the video", "input_file_id:stream_specifier" },
+    { "progressurl", HAS_ARG | OPT_EXPERT, { .func_arg = plex_opt_progress_url }, "write progress information via HTTP PUT", "url" },
+    { "loglevel_plex", HAS_ARG | OPT_EXPERT, { .func_arg = plex_opt_loglevel}, "log level for messages that will be sent to PMS", "" },
+    { "hwaccel_fallback_threshold", OPT_VIDEO | OPT_INT | HAS_ARG | OPT_EXPERT |
+                                    OPT_SPEC | OPT_INPUT,                    { .off = OFFSET(hwaccel_fallback_thresholds) },
+        "set when HW accelerated decoding should forcibly fall back", "fallback" },
+//PLEX
+
     { NULL, },
 };
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/ffprobe.c /home/klogg/Downloads/ffmpeg-plex/ffprobe.c
--- FFmpeg-Plex-Transcoder/ffprobe.c	2017-05-16 16:07:56.050792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/ffprobe.c	2017-05-04 13:47:00.000000000 +0300
@@ -1658,21 +1658,10 @@
     return 0;
 }
 
-static const char *xml_escape_str(AVBPrint *dst, const char *src, void *log_ctx)
+static const char *xml_escape_str(AVBPrint *dst, const char *src)
 {
-    const char *p;
-
-    for (p = src; *p; p++) {
-        switch (*p) {
-        case '&' : av_bprintf(dst, "%s", "&amp;");  break;
-        case '<' : av_bprintf(dst, "%s", "&lt;");   break;
-        case '>' : av_bprintf(dst, "%s", "&gt;");   break;
-        case '"' : av_bprintf(dst, "%s", "&quot;"); break;
-        case '\'': av_bprintf(dst, "%s", "&apos;"); break;
-        default: av_bprint_chars(dst, *p, 1);
-        }
-    }
-
+    av_bprint_clear(dst);
+    av_bprint_escape(dst, src, NULL, AV_ESCAPE_MODE_XML, AV_ESCAPE_FLAG_ESCAPE_DOUBLE_QUOTE);
     return dst->str;
 }
 
@@ -1747,14 +1736,12 @@
 
     if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) {
         XML_INDENT();
-        printf("<%s key=\"%s\"",
-               section->element_name, xml_escape_str(&buf, key, wctx));
-        av_bprint_clear(&buf);
-        printf(" value=\"%s\"/>\n", xml_escape_str(&buf, value, wctx));
+        printf("<%s key=\"%s\"", section->element_name, xml_escape_str(&buf, key));
+        printf(" value=\"%s\"/>\n", xml_escape_str(&buf, value));
     } else {
         if (wctx->nb_item[wctx->level])
             printf(" ");
-        printf("%s=\"%s\"", key, xml_escape_str(&buf, value, wctx));
+        printf("%s=\"%s\"", key, xml_escape_str(&buf, value));
     }
 
     av_bprint_finalize(&buf, NULL);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aac_ac3_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_ac3_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/aac_ac3_parser.c	2017-05-16 15:47:03.698792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_ac3_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -36,6 +36,21 @@
     int new_frame_start;
     int got_frame = 0;
 
+    if ((s1->flags & PARSER_FLAG_SKIP && s->parse_full) || avctx->extradata_size) {
+        s->remaining_size = 0;
+        s1->flags |= PARSER_FLAG_COMPLETE_FRAMES;
+        s1->duration = -1;
+        if (s1->flags & PARSER_FLAG_ONCE) {
+            got_frame = 1;
+            i = buf_size;
+            goto skip_sync;
+        } else {
+            *poutbuf = buf;
+            *poutbuf_size = buf_size;
+            return buf_size;
+        }
+    }
+
 get_next:
     i=END_NOT_FOUND;
     if(s->remaining_size <= buf_size){
@@ -71,6 +86,7 @@
         return buf_size;
     }
 
+skip_sync:
     *poutbuf = buf;
     *poutbuf_size = buf_size;
 
@@ -78,12 +94,12 @@
     if(s->codec_id)
         avctx->codec_id = s->codec_id;
 
+    if (s->parse_full && s1->flags & PARSER_FLAG_ONCE) {
+        if (!s->parse_full(s1, avctx, buf, buf_size))
+            s1->flags &= ~PARSER_FLAG_ONCE;
+    }
+
     if (got_frame) {
-        /* Due to backwards compatible HE-AAC the sample rate, channel count,
-           and total number of samples found in an AAC ADTS header are not
-           reliable. Bit rate is still accurate because the total frame
-           duration in seconds is still correct (as is the number of bits in
-           the frame). */
         if (avctx->codec_id != AV_CODEC_ID_AAC) {
             avctx->sample_rate = s->sample_rate;
 
@@ -102,6 +118,8 @@
             }
             s1->duration = s->samples;
             avctx->audio_service_type = s->service_type;
+
+            avctx->sample_fmt = AV_SAMPLE_FMT_S16P;
         }
 
         avctx->bit_rate = s->bit_rate;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aac_ac3_parser.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_ac3_parser.h
--- FFmpeg-Plex-Transcoder/libavcodec/aac_ac3_parser.h	2017-05-16 15:47:03.698792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_ac3_parser.h	2017-05-04 13:47:00.000000000 +0300
@@ -43,6 +43,8 @@
     int header_size;
     int (*sync)(uint64_t state, struct AACAC3ParseContext *hdr_info,
             int *need_next_header, int *new_frame_start);
+    int (*parse_full)(AVCodecParserContext *s1, AVCodecContext *avctx,
+                      const uint8_t *buf, int buf_size);
 
     int channels;
     int sample_rate;
@@ -50,6 +52,7 @@
     int samples;
     uint64_t channel_layout;
     int service_type;
+    int profile;
 
     int remaining_size;
     uint64_t state;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aacdec_template.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/aacdec_template.c
--- FFmpeg-Plex-Transcoder/libavcodec/aacdec_template.c	2017-05-16 15:47:03.702792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aacdec_template.c	2017-05-04 13:47:00.000000000 +0300
@@ -91,9 +91,6 @@
 
 #include "libavutil/thread.h"
 
-static VLC vlc_scalefactors;
-static VLC vlc_spectral[11];
-
 static int output_configure(AACContext *ac,
                             uint8_t layout_map[MAX_ELEM_ID*4][3], int tags,
                             enum OCStatus oc_type, int get_new_frame);
@@ -1081,44 +1078,14 @@
         reset_predict_state(&ps[i]);
 }
 
-#define AAC_INIT_VLC_STATIC(num, size)                                     \
-    INIT_VLC_STATIC(&vlc_spectral[num], 8, ff_aac_spectral_sizes[num],     \
-         ff_aac_spectral_bits[num], sizeof(ff_aac_spectral_bits[num][0]),  \
-                                    sizeof(ff_aac_spectral_bits[num][0]),  \
-        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), \
-                                    sizeof(ff_aac_spectral_codes[num][0]), \
-        size);
-
-static void aacdec_init(AACContext *ac);
-
 static av_cold void aac_static_table_init(void)
 {
-    AAC_INIT_VLC_STATIC( 0, 304);
-    AAC_INIT_VLC_STATIC( 1, 270);
-    AAC_INIT_VLC_STATIC( 2, 550);
-    AAC_INIT_VLC_STATIC( 3, 300);
-    AAC_INIT_VLC_STATIC( 4, 328);
-    AAC_INIT_VLC_STATIC( 5, 294);
-    AAC_INIT_VLC_STATIC( 6, 306);
-    AAC_INIT_VLC_STATIC( 7, 268);
-    AAC_INIT_VLC_STATIC( 8, 510);
-    AAC_INIT_VLC_STATIC( 9, 366);
-    AAC_INIT_VLC_STATIC(10, 462);
+    ff_thread_once(&ff_aac_table_init_common, &ff_aac_static_table_init_common);
 
     AAC_RENAME(ff_aac_sbr_init)();
 
     ff_aac_tableinit();
 
-    INIT_VLC_STATIC(&vlc_scalefactors, 7,
-                    FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
-                    ff_aac_scalefactor_bits,
-                    sizeof(ff_aac_scalefactor_bits[0]),
-                    sizeof(ff_aac_scalefactor_bits[0]),
-                    ff_aac_scalefactor_code,
-                    sizeof(ff_aac_scalefactor_code[0]),
-                    sizeof(ff_aac_scalefactor_code[0]),
-                    352);
-
     // window initialization
     AAC_RENAME(ff_kbd_window_init)(AAC_RENAME(ff_aac_kbd_long_1024), 4.0, 1024);
     AAC_RENAME(ff_kbd_window_init)(AAC_RENAME(ff_aac_kbd_short_128), 6.0, 128);
@@ -1131,6 +1098,8 @@
 
 static AVOnce aac_table_init = AV_ONCE_INIT;
 
+static void aacdec_init(AACContext *ac);
+
 static av_cold int aac_decode_init(AVCodecContext *avctx)
 {
     AACContext *ac = avctx->priv_data;
@@ -1450,7 +1419,7 @@
             } else if ((band_type[idx] == INTENSITY_BT) ||
                        (band_type[idx] == INTENSITY_BT2)) {
                 for (; i < run_end; i++, idx++) {
-                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
+                    offset[2] += get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
                     clipped_offset = av_clip(offset[2], -155, 100);
                     if (offset[2] != clipped_offset) {
                         avpriv_request_sample(ac->avctx,
@@ -1469,7 +1438,7 @@
                     if (noise_flag-- > 0)
                         offset[1] += get_bits(gb, NOISE_PRE_BITS) - NOISE_PRE;
                     else
-                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
+                        offset[1] += get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
                     clipped_offset = av_clip(offset[1], -100, 155);
                     if (offset[1] != clipped_offset) {
                         avpriv_request_sample(ac->avctx,
@@ -1485,7 +1454,7 @@
                 }
             } else {
                 for (; i < run_end; i++, idx++) {
-                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
+                    offset[0] += get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO;
                     if (offset[0] > 255U) {
                         av_log(ac->avctx, AV_LOG_ERROR,
                                "Scalefactor (%d) out of range.\n", offset[0]);
@@ -1660,7 +1629,7 @@
                 const float *vq = ff_aac_codebook_vector_vals[cbt_m1];
 #endif /* !USE_FIXED */
                 const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
-                VLC_TYPE (*vlc_tab)[2] = vlc_spectral[cbt_m1].table;
+                VLC_TYPE (*vlc_tab)[2] = ff_vlc_spectral[cbt_m1].table;
                 OPEN_READER(re, gb);
 
                 switch (cbt_m1 >> 1) {
@@ -2189,7 +2158,7 @@
         INTFLOAT gain_cache = FIXR10(1.);
         if (c) {
             cge = coup->coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
-            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
+            gain = cge ? get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3) - 60: 0;
             gain_cache = GET_GAIN(scale, gain);
         }
         if (coup->coupling_point == AFTER_IMDCT) {
@@ -2199,7 +2168,7 @@
                 for (sfb = 0; sfb < sce->ics.max_sfb; sfb++, idx++) {
                     if (sce->band_type[idx] != ZERO_BT) {
                         if (!cge) {
-                            int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                            int t = get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3) - 60;
                             if (t) {
                                 int s = 1;
                                 t = gain += t;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aac_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/aac_parser.c	2017-05-16 15:47:03.698792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aac_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -21,6 +21,9 @@
  */
 
 #include "parser.h"
+#include "aac.h"
+#include "aacdectab.h"
+#include "aactab.h"
 #include "aac_ac3_parser.h"
 #include "aacadtsdec.h"
 #include "get_bits.h"
@@ -51,11 +54,847 @@
     return size;
 }
 
+/**
+ * Individual Channel Stream
+ */
+typedef struct PIndividualChannelStream {
+    uint8_t max_sfb;            ///< number of scalefactor bands per group
+    enum WindowSequence window_sequence[2];
+    uint8_t use_kb_window[2];   ///< If set, use Kaiser-Bessel window, otherwise use a sine window.
+    int num_window_groups;
+    uint8_t group_len[8];
+    const uint16_t *swb_offset; ///< table of offsets to the lowest spectral coefficient of a scalefactor band, sfb, for a particular window
+    int num_swb;                ///< number of scalefactor window bands
+    int num_windows;
+    int tns_max_bands;
+    int predictor_present;
+    int predictor_reset_group;
+} PIndividualChannelStream;
+
+/**
+ * Single Channel Element - used for both SCE and LFE elements.
+ */
+typedef struct PSingleChannelElement {
+    PIndividualChannelStream ics;
+    enum BandType band_type[128];                   ///< band types
+    int band_type_run_end[120];                     ///< band type run end points
+} PSingleChannelElement;
+
+/**
+ * channel element - generic struct for SCE/CPE/CCE/LFE
+ */
+typedef struct PChannelElement {
+    PSingleChannelElement ch[2];
+} PChannelElement;
+
+static int decode_pce(AVCodecParserContext *s1, GetBitContext *gb)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, orig_num, i;
+    int comment_len;
+    uint64_t layout = 0;
+
+    skip_bits(gb, 2);  // object_type
+    skip_bits(gb, 4); // sampling_index
+
+    num_front       = get_bits(gb, 4);
+    num_side        = get_bits(gb, 4);
+    num_back        = get_bits(gb, 4);
+    num_lfe         = get_bits(gb, 2);
+    num_assoc_data  = get_bits(gb, 3);
+    num_cc          = get_bits(gb, 4);
+
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // mono_mixdown_tag
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // stereo_mixdown_tag
+
+    if (get_bits1(gb))
+        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
+
+#define GET_PAIRS(type) \
+    orig_num = num_ ## type; \
+    for (i = 0; i < orig_num; i++) { \
+        num_ ## type += get_bits1(gb); \
+        skip_bits(gb, 4); \
+    }
+
+    GET_PAIRS(front)
+    GET_PAIRS(side)
+    GET_PAIRS(back)
+
+    if (num_side == 0 && num_back >= 4) {
+        num_side = 2;
+        num_back -= 2;
+    }
+
+    if (num_front & 1) {
+        layout |= AV_CH_FRONT_CENTER;
+        num_front--;
+    }
+    if (num_front >= 4) {
+        layout |= AV_CH_FRONT_LEFT_OF_CENTER | AV_CH_FRONT_RIGHT_OF_CENTER;
+        num_front -= 2;
+    }
+    if (num_front >= 2)
+        layout |= AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT;
+
+    if (num_side >= 2)
+        layout |= AV_CH_SIDE_LEFT | AV_CH_SIDE_RIGHT;
+
+    if (num_back & 1) {
+        layout |= AV_CH_BACK_CENTER;
+        num_back--;
+    }
+    if (num_back >= 2)
+        layout |= AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT;
+
+    if (num_lfe)
+        layout |= AV_CH_LOW_FREQUENCY;
+
+    skip_bits_long(gb, 4 * (num_lfe + num_assoc_data + num_cc));
+    skip_bits_long(gb, (num_cc));
+
+    align_get_bits(gb);
+
+    /* comment field, first byte is length */
+    comment_len = get_bits(gb, 8) * 8;
+    if (get_bits_left(gb) < comment_len)
+        return AVERROR_INVALIDDATA;
+    skip_bits_long(gb, comment_len);
+
+    s->channel_layout = layout;
+    s->channels = av_get_channel_layout_nb_channels(s->channel_layout);
+
+    return 0;
+}
+
+static int set_default_channels(AVCodecParserContext *s1, int channel_config)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    if (channel_config < 1 || (channel_config > 7 && channel_config < 11) ||
+        channel_config > 12)
+        return AVERROR_INVALIDDATA;
+    s->channel_layout = aac_channel_layout[channel_config - 1];
+    if (channel_config == 7)
+        s->channel_layout = AV_CH_LAYOUT_7POINT1;
+    s->channels = av_get_channel_layout_nb_channels(s->channel_layout);
+    return 0;
+}
+
+static int skip_data_stream_element(GetBitContext *gb)
+{
+    int byte_align = get_bits1(gb);
+    int count = get_bits(gb, 8);
+    if (count == 255)
+        count += get_bits(gb, 8);
+    if (byte_align)
+        align_get_bits(gb);
+
+    if (get_bits_left(gb) < 8 * count)
+        return AVERROR_INVALIDDATA;
+
+    skip_bits_long(gb, 8 * count);
+    return 0;
+}
+
+static void skip_prediction(const MPEG4AudioConfig *m4ac, PIndividualChannelStream *ics,
+                            GetBitContext *gb)
+{
+    if (get_bits1(gb))
+        skip_bits(gb, 5);
+    skip_bits_long(gb, FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[m4ac->sampling_index]));
+}
+
+static void skip_ltp(GetBitContext *gb, uint8_t max_sfb)
+{
+    skip_bits(gb, 11);
+    skip_bits(gb, 3);
+    skip_bits_long(gb, FFMIN(max_sfb, MAX_LTP_LONG_SFB));
+}
+
+static int decode_band_types(GetBitContext *gb, enum BandType band_type[120],
+                             int band_type_run_end[120], PIndividualChannelStream *ics)
+{
+    int g, idx = 0;
+    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
+    for (g = 0; g < ics->num_window_groups; g++) {
+        int k = 0;
+        while (k < ics->max_sfb) {
+            uint8_t sect_end = k;
+            int sect_len_incr;
+            int sect_band_type = get_bits(gb, 4);
+            if (sect_band_type == 12) {
+                return AVERROR_INVALIDDATA;
+            }
+            do {
+                sect_len_incr = get_bits(gb, bits);
+                sect_end += sect_len_incr;
+                if (get_bits_left(gb) < 0) {
+                    return AVERROR_INVALIDDATA;
+                }
+                if (sect_end > ics->max_sfb) {
+                    return AVERROR_INVALIDDATA;
+                }
+            } while (sect_len_incr == (1 << bits) - 1);
+            for (; k < sect_end; k++) {
+                band_type        [idx]   = sect_band_type;
+                band_type_run_end[idx++] = sect_end;
+            }
+        }
+    }
+    return 0;
+}
+
+static void skip_scalefactors(GetBitContext *gb,
+                              PIndividualChannelStream *ics,
+                              enum BandType band_type[120],
+                              int band_type_run_end[120])
+{
+    int g, i, idx = 0;
+    int noise_flag = 1;
+    for (g = 0; g < ics->num_window_groups; g++) {
+        for (i = 0; i < ics->max_sfb;) {
+            int run_end = band_type_run_end[idx];
+            if (band_type[idx] == ZERO_BT) {
+                for (; i < run_end; i++, idx++);
+            } else if ((band_type[idx] == INTENSITY_BT) ||
+                       (band_type[idx] == INTENSITY_BT2)) {
+                for (; i < run_end; i++, idx++) {
+                    get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3);
+                }
+            } else if (band_type[idx] == NOISE_BT) {
+                for (; i < run_end; i++, idx++) {
+                    if (noise_flag-- > 0)
+                        skip_bits(gb, NOISE_PRE_BITS);
+                    else
+                        get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3);
+                }
+            } else {
+                for (; i < run_end; i++, idx++) {
+                    get_vlc2(gb, ff_vlc_scalefactors.table, 7, 3);
+                }
+            }
+        }
+    }
+}
+
+static void skip_pulses(GetBitContext *gb, int num_swb)
+{
+    int i;
+    int num_pulse = get_bits(gb, 2) + 1;
+    skip_bits(gb, 6);
+    skip_bits(gb, 5);
+    skip_bits(gb, 4);
+    for (i = 1; i < num_pulse; i++) {
+        skip_bits(gb, 5);
+        skip_bits(gb, 4);
+    }
+}
+
+static void skip_tns(GetBitContext *gb, const PIndividualChannelStream *ics,
+                     const MPEG4AudioConfig *m4ac)
+{
+    int w, filt, i, coef_len, coef_res, coef_compress;
+    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;
+    for (w = 0; w < ics->num_windows; w++) {
+        int n_filt;
+        if ((n_filt = get_bits(gb, 2 - is8))) {
+            coef_res = get_bits1(gb);
+
+            for (filt = 0; filt < n_filt; filt++) {
+                int order;
+                skip_bits(gb, 6 - 2 * is8);
+
+                order = get_bits(gb, 5 - 2 * is8);
+                if (order) {
+                    skip_bits1(gb);
+                    coef_compress = get_bits1(gb);
+                    coef_len = coef_res + 3 - coef_compress;
+
+                    for (i = 0; i < order; i++)
+                        get_bits(gb, coef_len);
+                }
+            }
+        }
+    }
+}
+
+static void skip_mid_side_stereo(PIndividualChannelStream *ics, GetBitContext *gb,
+                                 int ms_present)
+{
+    if (ms_present == 1) {
+        int max_idx = ics->num_window_groups * ics->max_sfb;
+        skip_bits_long(gb, max_idx);
+    }
+}
+
+static int skip_spectrum_and_dequant(GetBitContext *gb, const PIndividualChannelStream *ics,
+                                     enum BandType band_type[120])
+{
+    int i, g, idx = 0;
+    const uint16_t *offsets = ics->swb_offset;
+
+    for (g = 0; g < ics->num_window_groups; g++) {
+        unsigned g_len = ics->group_len[g];
+
+        for (i = 0; i < ics->max_sfb; i++, idx++) {
+            const unsigned cbt_m1 = band_type[idx] - 1;
+            int off_len = offsets[i + 1] - offsets[i];
+            int group;
+
+            if (cbt_m1 < NOISE_BT - 1) {
+                VLC_TYPE (*vlc_tab)[2] = ff_vlc_spectral[cbt_m1].table;
+                const uint16_t *cb_vector_idx = ff_aac_codebook_vector_idx[cbt_m1];
+                OPEN_READER(re, gb);
+
+                switch (cbt_m1 >> 1) {
+                case 0:
+                    for (group = 0; group < (int)g_len; group++) {
+                        int len = off_len;
+
+                        do {
+                            int code;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 1:
+                    for (group = 0; group < (int)g_len; group++) {
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 8 & 15;
+                            if (nnz)
+                                GET_CACHE(re, gb);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                        } while (len -= 4);
+                    }
+                    break;
+
+                case 2:
+                    for (group = 0; group < (int)g_len; group++) {
+                        int len = off_len;
+
+                        do {
+                            int code;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                case 3:
+                case 4:
+                    for (group = 0; group < (int)g_len; group++) {
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nnz;
+                            unsigned cb_idx;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 8 & 15;
+                            if (nnz)
+                                SHOW_UBITS(re, gb, nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+                        } while (len -= 2);
+                    }
+                    break;
+
+                default:
+                    for (group = 0; group < (int)g_len; group++) {
+                        int len = off_len;
+
+                        do {
+                            int code;
+                            unsigned nzt, nnz;
+                            unsigned cb_idx;
+                            uint32_t bits;
+                            int j;
+
+                            UPDATE_CACHE(re, gb);
+                            GET_VLC(code, re, gb, vlc_tab, 8, 2);
+
+                            if (!code) {
+                                continue;
+                            }
+
+                            cb_idx = cb_vector_idx[code];
+                            nnz = cb_idx >> 12;
+                            nzt = cb_idx >> 8;
+                            bits = SHOW_UBITS(re, gb, nnz) << (32-nnz);
+                            LAST_SKIP_BITS(re, gb, nnz);
+
+                            for (j = 0; j < 2; j++) {
+                                if (nzt & 1<<j) {
+                                    uint32_t b;
+                                    /* The total length of escape_sequence must be < 22 bits according
+                                       to the specification (i.e. max is 111111110xxxxxxxxxxxx). */
+                                    UPDATE_CACHE(re, gb);
+                                    b = GET_CACHE(re, gb);
+                                    b = 31 - av_log2(~b);
+
+                                    if (b > 8) {
+                                        return AVERROR_INVALIDDATA;
+                                    }
+
+                                    SKIP_BITS(re, gb, b + 1);
+                                    b += 4;
+                                    LAST_SKIP_BITS(re, gb, b);
+                                    bits <<= 1;
+                                } else {
+                                    int v = cb_idx & 15;
+                                    if (bits & 1U<<31)
+                                        v = -v;
+                                    bits <<= !!v;
+                                }
+                                cb_idx >>= 4;
+                            }
+                        } while (len -= 2);
+                    }
+                }
+
+                CLOSE_READER(re, gb);
+            }
+        }
+    }
+    return 0;
+}
+
+static int decode_ics_info(const MPEG4AudioConfig *m4ac, PIndividualChannelStream *ics,
+                           GetBitContext *gb)
+{
+    const int aot = m4ac->object_type;
+    const int sampling_index = m4ac->sampling_index;
+    if (aot != AOT_ER_AAC_ELD) {
+        skip_bits1(gb);
+        ics->window_sequence[0] = get_bits(gb, 2);
+        if (aot == AOT_ER_AAC_LD && ics->window_sequence[0] != ONLY_LONG_SEQUENCE)
+            return AVERROR_INVALIDDATA;
+        ics->use_kb_window[0]   = get_bits1(gb);
+    }
+    ics->num_window_groups  = 1;
+    ics->group_len[0]       = 1;
+    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        int i;
+        ics->max_sfb = get_bits(gb, 4);
+        for (i = 0; i < 7; i++) {
+            if (get_bits1(gb)) {
+                ics->group_len[ics->num_window_groups - 1]++;
+            } else {
+                ics->num_window_groups++;
+                ics->group_len[ics->num_window_groups - 1] = 1;
+            }
+        }
+        ics->num_windows       = 8;
+        ics->swb_offset        =    ff_swb_offset_128[sampling_index];
+        ics->num_swb           =   ff_aac_num_swb_128[sampling_index];
+        ics->tns_max_bands     = ff_tns_max_bands_128[sampling_index];
+        ics->predictor_present = 0;
+    } else {
+        ics->max_sfb           = get_bits(gb, 6);
+        ics->num_windows       = 1;
+        if (aot == AOT_ER_AAC_LD || aot == AOT_ER_AAC_ELD) {
+            if (m4ac->frame_length_short) {
+                ics->swb_offset    =     ff_swb_offset_480[sampling_index];
+                ics->num_swb       =    ff_aac_num_swb_480[sampling_index];
+                ics->tns_max_bands =  ff_tns_max_bands_480[sampling_index];
+            } else {
+                ics->swb_offset    =     ff_swb_offset_512[sampling_index];
+                ics->num_swb       =    ff_aac_num_swb_512[sampling_index];
+                ics->tns_max_bands =  ff_tns_max_bands_512[sampling_index];
+            }
+            if (!ics->num_swb || !ics->swb_offset)
+                return AVERROR_BUG;
+        } else {
+            ics->swb_offset    =    ff_swb_offset_1024[sampling_index];
+            ics->num_swb       =   ff_aac_num_swb_1024[sampling_index];
+            ics->tns_max_bands = ff_tns_max_bands_1024[sampling_index];
+        }
+        if (aot != AOT_ER_AAC_ELD) {
+            ics->predictor_present     = get_bits1(gb);
+            ics->predictor_reset_group = 0;
+        }
+        if (ics->predictor_present) {
+            if (aot == AOT_AAC_MAIN) {
+                skip_prediction(m4ac, ics, gb);
+            } else if (aot == AOT_AAC_LC ||
+                       aot == AOT_ER_AAC_LC) {
+                goto fail;
+            } else {
+                if (aot == AOT_ER_AAC_LD) {
+                    return AVERROR_PATCHWELCOME;
+                }
+                if (get_bits(gb, 1))
+                    skip_ltp(gb, ics->max_sfb);
+            }
+        }
+    }
+
+    if (ics->max_sfb > ics->num_swb)
+        goto fail;
+
+    return 0;
+fail:
+    ics->max_sfb = 0;
+    return AVERROR_INVALIDDATA;
+}
+
+static int decode_ics(MPEG4AudioConfig *m4ac, PSingleChannelElement *sce,
+                      GetBitContext *gb, int common_window, int scale_flag)
+{
+    PIndividualChannelStream *ics;
+    enum BandType *band_type;
+    int *band_type_run_end;
+    int eld_syntax, er_syntax, pulse_present = 0;
+    int aot = m4ac->object_type;
+    PIndividualChannelStream ics_local;
+    enum BandType band_type_local[120];
+    int band_type_run_end_local[120];
+    int ret;
+
+    if (sce) {
+        ics = &sce->ics;
+        band_type = sce->band_type;
+        band_type_run_end = sce->band_type_run_end;
+    } else {
+        ics = &ics_local;
+        band_type = band_type_local;
+        band_type_run_end = band_type_run_end_local;
+    }
+
+
+    eld_syntax = aot == AOT_ER_AAC_ELD;
+    er_syntax  = aot == AOT_ER_AAC_LC  ||
+                 aot == AOT_ER_AAC_LTP ||
+                 aot == AOT_ER_AAC_LD  ||
+                 aot == AOT_ER_AAC_ELD;
+
+    skip_bits(gb, 8);
+
+    if (!common_window && !scale_flag) {
+        if (decode_ics_info(m4ac, ics, gb) < 0)
+            return AVERROR_INVALIDDATA;
+    }
+
+    if ((ret = decode_band_types(gb, band_type, band_type_run_end, ics)) < 0)
+        return ret;
+    skip_scalefactors(gb, ics, band_type, band_type_run_end);
+
+    if (!scale_flag) {
+        int tns_present;
+        if (!eld_syntax && (pulse_present = get_bits1(gb))) {
+            skip_pulses(gb, ics->num_swb);
+        }
+        tns_present = get_bits1(gb);
+        if (tns_present && !er_syntax)
+            skip_tns(gb, ics, m4ac);
+        if (!eld_syntax && get_bits1(gb))
+            return AVERROR_PATCHWELCOME;
+        // I see no textual basis in the spec for this occurring after SSR gain
+        // control, but this is what both reference and real implmentations do
+        if (tns_present && er_syntax)
+            skip_tns(gb, ics, m4ac);
+    }
+
+    if (skip_spectrum_and_dequant(gb, ics, band_type) < 0)
+        return AVERROR_INVALIDDATA;
+
+    return 0;
+}
+
+static int skip_cpe(MPEG4AudioConfig *m4ac, GetBitContext *gb)
+{
+    int ret, common_window, ms_present = 0;
+    int eld_syntax = m4ac->object_type == AOT_ER_AAC_ELD;
+    PChannelElement cpe;
+
+    common_window = eld_syntax || get_bits1(gb);
+    if (common_window) {
+        if (decode_ics_info(m4ac, &cpe.ch[0].ics, gb))
+            return AVERROR_INVALIDDATA;
+        //i = cpe.ch[1].ics.use_kb_window[0];
+        cpe.ch[1].ics = cpe.ch[0].ics;
+        //cpe.ch[1].ics.use_kb_window[1] = i;
+        if (cpe.ch[1].ics.predictor_present &&
+            (m4ac->object_type != AOT_AAC_MAIN))
+            if (get_bits(gb, 1))
+                skip_ltp(gb, cpe.ch[1].ics.max_sfb);
+        ms_present = get_bits(gb, 2);
+        if (ms_present == 3)
+            return AVERROR_INVALIDDATA;
+        else if (ms_present)
+            skip_mid_side_stereo(&cpe.ch[1].ics, gb, ms_present);
+    }
+    if ((ret = decode_ics(m4ac, &cpe.ch[0], gb, common_window, 0)))
+        return ret;
+    if ((ret = decode_ics(m4ac, &cpe.ch[1], gb, common_window, 0)))
+        return ret;
+
+    return 0;
+}
+
+static int skip_cce(MPEG4AudioConfig *m4ac, GetBitContext *gb)
+{
+    int num_gain = 0;
+    int c, g, sfb, ret, num_coupled, coupling_point;
+    PSingleChannelElement sce;
+    PIndividualChannelStream *ics = &sce.ics;
+
+    coupling_point = get_bits1(gb);
+    num_coupled = get_bits(gb, 3);
+    for (c = 0; c <= num_coupled; c++) {
+        int type = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
+        skip_bits(gb, 4);
+        num_gain++;
+        if (type == TYPE_CPE) {
+            int ch_select = get_bits(gb, 2);
+            if (ch_select == 3)
+                num_gain++;
+        }
+    }
+    coupling_point += get_bits1(gb) || (coupling_point >> 1);
+
+    skip_bits1(gb);
+    skip_bits(gb, 2);
+
+    if ((ret = decode_ics(m4ac, &sce, gb, 0, 0)))
+        return ret;
+
+    for (c = 0; c < num_gain; c++) {
+        static VLC_TYPE table[352][2];
+        int idx  = 0;
+        int cge  = 1;
+        if (c) {
+            cge = coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
+            if (cge)
+                get_vlc2(gb, table, 7, 3);
+        }
+        if (coupling_point != AFTER_IMDCT) {
+            for (g = 0; g < ics->num_window_groups; g++) {
+                for (sfb = 0; sfb < ics->max_sfb; sfb++, idx++) {
+                    if (sce.band_type[idx] != ZERO_BT) {
+                        if (!cge) {
+                            get_vlc2(gb, table, 7, 3);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+static int decode_extension_payload(AVCodecParserContext *s1, MPEG4AudioConfig *m4ac,
+                                    GetBitContext *gb, int cnt)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    int res = cnt;
+    int type = get_bits(gb, 4);
+
+    if (type == EXT_SBR_DATA || type == EXT_SBR_DATA_CRC) { // extension type
+        if (m4ac->ps && s->channels == 1) {
+            m4ac->sbr = 1;
+            m4ac->ps = 1;
+            s->channels = 2;
+            s->channel_layout = AV_CH_LAYOUT_STEREO;
+            m4ac->sample_rate *= 2;
+            s->profile = FF_PROFILE_AAC_HE_V2;
+        } else {
+            m4ac->sbr = 1;
+            m4ac->sample_rate *= 2;
+            s->profile = FF_PROFILE_AAC_HE;
+        }
+    };
+    skip_bits_long(gb, 8 * cnt - 4);
+
+    return res;
+}
+
+static int parse_frame(AVCodecParserContext *s1, MPEG4AudioConfig *m4ac, GetBitContext *gb)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    enum RawDataBlockType elem_type;
+    int elem_id, err = 0, sample_rate = m4ac->sample_rate;
+    while ((elem_type = get_bits(gb, 3)) != TYPE_END) {
+        elem_id = get_bits(gb, 4);
+
+        switch (elem_type) {
+        case TYPE_SCE:
+        case TYPE_LFE:
+            err = decode_ics(m4ac, NULL, gb, 0, 0);
+            break;
+
+        case TYPE_CPE:
+            err = skip_cpe(m4ac, gb);
+            break;
+
+        case TYPE_CCE:
+            err = skip_cce(m4ac, gb);
+            break;
+
+        case TYPE_DSE:
+            err = skip_data_stream_element(gb);
+            break;
+
+        case TYPE_PCE:
+            err = decode_pce(s1, gb);
+            break;
+
+        case TYPE_FIL:
+            if (elem_id == 15)
+                elem_id += get_bits(gb, 8) - 1;
+            if (get_bits_left(gb) < 8 * elem_id) {
+                return AVERROR_INVALIDDATA;
+            }
+            while (elem_id > 0)
+                elem_id -= decode_extension_payload(s1, m4ac, gb, elem_id);
+            break;
+
+        default:
+            err = AVERROR_BUG; /* should not happen, but keeps compiler happy */
+            break;
+        }
+
+        if (err)
+            return AVERROR_INVALIDDATA;
+
+        if (get_bits_left(gb) < 3)
+            return AVERROR_INVALIDDATA;
+    }
+
+    if (m4ac->sample_rate > sample_rate)
+        s->samples *= 2;
+
+    return 0;
+}
+
+static int aac_parse_full(AVCodecParserContext *s1, AVCodecContext *avctx,
+                          const uint8_t *buf, int buf_size)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    int aot, ret, frame_length_short = 0;
+    GetBitContext gb;
+    MPEG4AudioConfig m4ac = {0};
+    init_get_bits8(&gb, buf, buf_size);
+    if (avctx->extradata) {
+        GetBitContext gb2;
+        int len;
+        if (avctx->extradata_size > INT_MAX / 8)
+            return AVERROR_INVALIDDATA;
+        if ((len = avpriv_mpeg4audio_get_config(&m4ac, avctx->extradata,
+                                                avctx->extradata_size * 8, 1)) < 0)
+            return AVERROR_INVALIDDATA;
+        if (m4ac.sampling_index > 12) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "invalid sampling rate index %d\n",
+                   m4ac.sampling_index);
+            return AVERROR_INVALIDDATA;
+        }
+        if (m4ac.object_type == AOT_ER_AAC_LD &&
+            (m4ac.sampling_index < 3 || m4ac.sampling_index > 7)) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "invalid low delay sampling rate index %d\n",
+                   m4ac.sampling_index);
+            return AVERROR_INVALIDDATA;
+        }
+        init_get_bits8(&gb2, avctx->extradata, avctx->extradata_size);
+        skip_bits_long(&gb2, len);
+        m4ac.frame_length_short = get_bits1(&gb2);
+        if (m4ac.chan_config == 0 &&
+            (m4ac.object_type == AOT_AAC_MAIN ||
+             m4ac.object_type == AOT_AAC_LC ||
+             m4ac.object_type == AOT_AAC_LTP ||
+             m4ac.object_type == AOT_ER_AAC_LC ||
+             m4ac.object_type == AOT_ER_AAC_LD)) {
+            if (get_bits1(&gb2))     // dependsOnCoreCoder
+                skip_bits(&gb2, 14); // coreCoderDelay
+            skip_bits1(&gb2);
+            if (m4ac.object_type == AOT_AAC_SCALABLE ||
+                m4ac.object_type == AOT_ER_AAC_SCALABLE)
+                skip_bits(&gb2, 3);  // layerNr
+            skip_bits(&gb2, 4);      // element_instance_tag
+            if ((ret = decode_pce(s1, &gb2)) < 0)
+                return ret;
+        } else {
+            if ((ret = set_default_channels(s1, m4ac.chan_config)) < 0)
+                return ret;
+        }
+    } else if (show_bits(&gb, 12) == 0xfff) {
+        AACADTSHeaderInfo hdr_info;
+        if ((ret = avpriv_aac_parse_header(&gb, &hdr_info)) < 0)
+            return ret;
+
+        m4ac.chan_config = hdr_info.chan_config;
+        if (hdr_info.chan_config) {
+            if ((ret = set_default_channels(s1, hdr_info.chan_config)) < 0)
+                return ret;
+        }
+        m4ac.sample_rate     = hdr_info.sample_rate;
+        m4ac.sampling_index  = hdr_info.sampling_index;
+        m4ac.object_type     = hdr_info.object_type;
+        m4ac.frame_length_short = 0;
+        m4ac.sbr = -1;
+        m4ac.ps  = -1;
+        if (!hdr_info.crc_absent)
+            skip_bits(&gb, 16);
+    }
+
+    aot = m4ac.object_type;
+    if (aot > 0)
+        s->profile = aot - 1;
+
+    if (aot == AOT_ER_AAC_LC ||
+        aot == AOT_ER_AAC_LTP ||
+        aot == AOT_ER_AAC_LD ||
+        aot == AOT_ER_AAC_ELD) {
+        s->samples = frame_length_short ? 960 : 1024;
+        if (aot == AOT_ER_AAC_LD || aot == AOT_ER_AAC_ELD)
+            s->samples >>= 1;
+    } else {
+        s->samples = 1024;
+        if (ff_thread_once(&ff_aac_table_init_common, &ff_aac_static_table_init_common))
+            return AVERROR_UNKNOWN;
+        parse_frame(s1, &m4ac, &gb);
+    }
+
+    s1->duration = s->samples;
+
+    if (avctx->profile == FF_PROFILE_UNKNOWN)
+        avctx->profile = s->profile;
+    if (!avctx->channels) {
+        avctx->channels = s->channels;
+        avctx->channel_layout = s->channel_layout;
+    }
+    if (!avctx->sample_rate)
+        avctx->sample_rate = m4ac.sample_rate;
+
+    return 0;
+}
+
+
 static av_cold int aac_parse_init(AVCodecParserContext *s1)
 {
     AACAC3ParseContext *s = s1->priv_data;
     s->header_size = AAC_ADTS_HEADER_SIZE;
     s->sync = aac_sync;
+    s->parse_full = aac_parse_full;
+    s1->flags |= PARSER_FLAG_ONCE;
     return 0;
 }
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aactab.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/aactab.c
--- FFmpeg-Plex-Transcoder/libavcodec/aactab.c	2017-05-16 15:47:03.710792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aactab.c	2017-05-04 13:47:00.000000000 +0300
@@ -28,6 +28,7 @@
  */
 
 #include "libavutil/mem.h"
+#include "libavutil/thread.h"
 #include "aac.h"
 
 #include <stdint.h>
@@ -3160,3 +3161,42 @@
     0xffecff1c, 0xffed391e, 0xffed740c, 0xffedafb1,
     0xffedebe1, 0xffee287d, 0xffee654e, 0xffeea23f,
 };
+
+VLC ff_vlc_scalefactors;
+VLC ff_vlc_spectral[11];
+
+#define AAC_INIT_VLC_STATIC(num, size)                                     \
+    INIT_VLC_STATIC(&ff_vlc_spectral[num], 8, ff_aac_spectral_sizes[num],  \
+         ff_aac_spectral_bits[num], sizeof(ff_aac_spectral_bits[num][0]),  \
+                                    sizeof(ff_aac_spectral_bits[num][0]),  \
+        ff_aac_spectral_codes[num], sizeof(ff_aac_spectral_codes[num][0]), \
+                                    sizeof(ff_aac_spectral_codes[num][0]), \
+        size);
+
+av_cold void ff_aac_static_table_init_common(void);
+av_cold void ff_aac_static_table_init_common(void)
+{
+    AAC_INIT_VLC_STATIC( 0, 304);
+    AAC_INIT_VLC_STATIC( 1, 270);
+    AAC_INIT_VLC_STATIC( 2, 550);
+    AAC_INIT_VLC_STATIC( 3, 300);
+    AAC_INIT_VLC_STATIC( 4, 328);
+    AAC_INIT_VLC_STATIC( 5, 294);
+    AAC_INIT_VLC_STATIC( 6, 306);
+    AAC_INIT_VLC_STATIC( 7, 268);
+    AAC_INIT_VLC_STATIC( 8, 510);
+    AAC_INIT_VLC_STATIC( 9, 366);
+    AAC_INIT_VLC_STATIC(10, 462);
+
+    INIT_VLC_STATIC(&ff_vlc_scalefactors, 7,
+                    FF_ARRAY_ELEMS(ff_aac_scalefactor_code),
+                    ff_aac_scalefactor_bits,
+                    sizeof(ff_aac_scalefactor_bits[0]),
+                    sizeof(ff_aac_scalefactor_bits[0]),
+                    ff_aac_scalefactor_code,
+                    sizeof(ff_aac_scalefactor_code[0]),
+                    sizeof(ff_aac_scalefactor_code[0]),
+                    352);
+}
+
+AVOnce ff_aac_table_init_common = AV_ONCE_INIT;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aactab.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/aactab.h
--- FFmpeg-Plex-Transcoder/libavcodec/aactab.h	2017-05-16 15:47:03.710792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aactab.h	2017-05-04 13:47:00.000000000 +0300
@@ -31,6 +31,7 @@
 #define AVCODEC_AACTAB_H
 
 #include "libavutil/mem.h"
+#include "libavutil/thread.h"
 #include "aac.h"
 
 #include <stdint.h>
@@ -177,4 +178,10 @@
 extern const uint8_t ff_tns_max_bands_480 [13];
 extern const uint8_t ff_tns_max_bands_128 [13];
 
+extern VLC ff_vlc_scalefactors;
+extern VLC ff_vlc_spectral[11];
+
+void ff_aac_static_table_init_common(void);
+extern AVOnce ff_aac_table_init_common;
+
 #endif /* AVCODEC_AACTAB_H */
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/aarch64/h264cmc_neon.S /home/klogg/Downloads/ffmpeg-plex/libavcodec/aarch64/h264cmc_neon.S
--- FFmpeg-Plex-Transcoder/libavcodec/aarch64/h264cmc_neon.S	2017-05-16 15:47:03.710792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/aarch64/h264cmc_neon.S	2017-05-04 13:47:00.000000000 +0300
@@ -428,7 +428,6 @@
         h264_chroma_mc2 put
         h264_chroma_mc2 avg
 
-#if CONFIG_RV40_DECODER
 const   rv40bias
         .short           0, 16, 32, 16
         .short          32, 28, 32, 28
@@ -440,11 +439,8 @@
         h264_chroma_mc8 avg, rv40
         h264_chroma_mc4 put, rv40
         h264_chroma_mc4 avg, rv40
-#endif
 
-#if CONFIG_VC1DSP
         h264_chroma_mc8 put, vc1
         h264_chroma_mc8 avg, vc1
         h264_chroma_mc4 put, vc1
         h264_chroma_mc4 avg, vc1
-#endif
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3dec.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3dec.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec.c	2017-05-04 13:47:00.000000000 +0300
@@ -349,12 +349,14 @@
         s->skip_syntax           = 1;
         memset(s->channel_uses_aht, 0, sizeof(s->channel_uses_aht));
         return ac3_parse_header(s);
-    } else if (CONFIG_EAC3_DECODER) {
+    } else {
+#if CONFIG_EAC3_DECODER
         s->eac3 = 1;
         return ff_eac3_parse_header(s);
-    } else {
+#else
         av_log(s->avctx, AV_LOG_ERROR, "E-AC-3 support not compiled in\n");
         return AVERROR(ENOSYS);
+#endif
     }
 }
 
@@ -609,6 +611,7 @@
     if (!s->channel_uses_aht[ch]) {
         ac3_decode_transform_coeffs_ch(s, ch, m);
     } else {
+#if CONFIG_EAC3_DECODER
         /* if AHT is used, mantissas for all blocks are encoded in the first
            block of the frame. */
         int bin;
@@ -617,6 +620,7 @@
         for (bin = s->start_freq[ch]; bin < s->end_freq[ch]; bin++) {
             s->fixed_coeffs[ch][bin] = s->pre_mantissa[ch][bin][blk] >> s->dexps[ch][bin];
         }
+#endif
     }
 }
 
@@ -811,6 +815,8 @@
         memcpy(band_sizes, bnd_sz, n_bands);
 }
 
+#if CONFIG_EAC3_DECODER
+
 static inline int spx_strategy(AC3DecodeContext *s, int blk)
 {
     GetBitContext *bc = &s->gbc;
@@ -945,6 +951,8 @@
     }
 }
 
+#endif
+
 static inline int coupling_strategy(AC3DecodeContext *s, int blk,
                                     uint8_t *bit_alloc_stages)
 {
@@ -997,10 +1005,17 @@
         s->start_freq[CPL_CH] = cpl_start_subband * 12 + 37;
         s->end_freq[CPL_CH]   = cpl_end_subband   * 12 + 37;
 
+#if CONFIG_EAC3_DECODER
         decode_band_structure(bc, blk, s->eac3, 0, cpl_start_subband,
                               cpl_end_subband,
                               ff_eac3_default_cpl_band_struct,
                               &s->num_cpl_bands, s->cpl_band_sizes);
+#else
+        decode_band_structure(bc, blk, 0, 0, cpl_start_subband,
+                              cpl_end_subband,
+                              NULL,
+                              &s->num_cpl_bands, s->cpl_band_sizes);
+#endif
     } else {
         /* coupling not in use */
         for (ch = 1; ch <= fbw_channels; ch++) {
@@ -1105,6 +1120,7 @@
         }
     } while (i--);
 
+#if CONFIG_EAC3_DECODER
     /* spectral extension strategy */
     if (s->eac3 && (!blk || get_bits1(gbc))) {
         s->spx_in_use = get_bits1(gbc);
@@ -1113,6 +1129,7 @@
                 return ret;
         }
     }
+#endif
     if (!s->eac3 || !s->spx_in_use) {
         s->spx_in_use = 0;
         for (ch = 1; ch <= fbw_channels; ch++) {
@@ -1121,9 +1138,11 @@
         }
     }
 
+#if CONFIG_EAC3_DECODER
     /* spectral extension coordinates */
     if (s->spx_in_use)
         spx_coordinates(s);
+#endif
 
     /* coupling strategy */
     if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {
@@ -1356,8 +1375,12 @@
         }
         if (bit_alloc_stages[ch] > 0) {
             /* Compute bit allocation */
+#if CONFIG_EAC3_DECODER
             const uint8_t *bap_tab = s->channel_uses_aht[ch] ?
                                      ff_eac3_hebap_tab : ff_ac3_bap_tab;
+#else
+            const uint8_t *bap_tab = ff_ac3_bap_tab;
+#endif
             s->ac3dsp.bit_alloc_calc_bap(s->mask[ch], s->psd[ch],
                                       s->start_freq[ch], s->end_freq[ch],
                                       s->snr_offset[ch],
@@ -1404,10 +1427,12 @@
 #endif
     }
 
+#if CONFIG_EAC3_DECODER
     /* apply spectral extension to high frequency bins */
     if (CONFIG_EAC3_DECODER && s->spx_in_use) {
         ff_eac3_apply_spectral_extension(s);
     }
+#endif
 
     /* downmix and MDCT. order depends on whether block switching is used for
        any channel in this block. this is because coefficients for the long
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3dec_data.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_data.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3dec_data.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_data.c	2017-05-04 13:47:00.000000000 +0300
@@ -43,6 +43,7 @@
     { 3, 0, 1 }, { 3, 0, 2 }, { 3, 1, 0 }, { 3, 1, 1 }
 };
 
+#if CONFIG_EAC3_DECODER
 const uint8_t ff_eac3_hebap_tab[64] = {
     0, 1, 2, 3, 4, 5, 6, 7, 8, 8,
     8, 8, 9, 9, 9, 10, 10, 10, 10, 11,
@@ -58,3 +59,4 @@
  */
 const uint8_t ff_eac3_default_spx_band_struct[17] =
 { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };
+#endif
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3dec_fixed.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_fixed.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3dec_fixed.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_fixed.c	2017-05-04 13:47:00.000000000 +0300
@@ -164,7 +164,9 @@
     }
 }
 
+#if CONFIG_EAC3_DECODER
 #include "eac3dec.c"
+#endif
 #include "ac3dec.c"
 
 static const AVOption options[] = {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3dec_float.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_float.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3dec_float.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3dec_float.c	2017-05-04 13:47:00.000000000 +0300
@@ -28,7 +28,9 @@
  * Upmix delay samples from stereo to original channel layout.
  */
 #include "ac3dec.h"
+#if CONFIG_EAC3_DECODER
 #include "eac3dec.c"
+#endif
 #include "ac3dec.c"
 
 static const AVOption options[] = {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3enc.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3enc.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc.c	2017-05-04 13:47:00.000000000 +0300
@@ -44,7 +44,9 @@
 #include "ac3.h"
 #include "fft.h"
 #include "ac3enc.h"
+#if CONFIG_EAC3_ENCODER
 #include "eac3enc.h"
+#endif
 
 typedef struct AC3Mant {
     int16_t *qmant1_ptr, *qmant2_ptr, *qmant4_ptr; ///< mantissa pointers for bap=1,2,4
@@ -317,8 +319,10 @@
     /* LFE */
     exponent_group_tab[0][0][7] = 2;
 
+#if CONFIG_EAC3_ENCODER
     if (CONFIG_EAC3_ENCODER && s->eac3)
         ff_eac3_exponent_init();
+#endif
 }
 
 
@@ -407,9 +411,11 @@
             s->exp_strategy[ch][blk] = EXP_REUSE;
     }
 
+#if CONFIG_EAC3_ENCODER
     /* for E-AC-3, determine frame exponent strategy */
     if (CONFIG_EAC3_ENCODER && s->eac3)
         ff_eac3_get_frame_exp_strategy(s);
+#endif
 }
 
 
@@ -668,6 +674,7 @@
     /* header */
     frame_bits = 16; /* sync info */
     if (s->eac3) {
+#if CONFIG_EAC3_ENCODER
         /* bitstream info header */
         frame_bits += 35;
         frame_bits += 1 + 1;
@@ -695,6 +702,7 @@
         /* block start info */
         if (s->num_blocks != 1)
             frame_bits++;
+#endif
     } else {
         frame_bits += 49;
         frame_bits += frame_bits_inc[s->channel_mode];
@@ -800,6 +808,7 @@
 
     /* header */
     if (s->eac3) {
+#if CONFIG_EAC3_ENCODER
         if (opt->eac3_mixing_metadata) {
             if (s->channel_mode > AC3_CHMODE_STEREO)
                 frame_bits += 2;
@@ -843,6 +852,7 @@
                     frame_bits += 2 * s->blocks[blk].cpl_in_use;
             }
         }
+#endif
     } else {
         if (opt->audio_production_info)
             frame_bits += 7;
@@ -2153,6 +2163,7 @@
 
     /* validate bit rate */
     if (s->eac3) {
+#if CONFIG_EAC3_ENCODER
         int max_br, min_br, wpf, min_br_code;
         int num_blks_code, num_blocks, frame_samples;
         long long min_br_dist;
@@ -2199,6 +2210,7 @@
         while (wpf > 1 && wpf * s->sample_rate / AC3_FRAME_SIZE * 16 > avctx->bit_rate)
             wpf--;
         s->frame_size_min = 2 * wpf;
+#endif
     } else {
         int best_br = 0, best_code = 0;
         long long best_diff = INT64_MAX;
@@ -2429,7 +2441,9 @@
 
     s->avctx = avctx;
 
+#if CONFIG_EAC3_ENCODER
     s->eac3 = avctx->codec_id == AV_CODEC_ID_EAC3;
+#endif
 
     ret = validate_options(s);
     if (ret)
@@ -2463,9 +2477,11 @@
         s->mdct_init                    = ff_ac3_float_mdct_init;
         s->allocate_sample_buffers      = ff_ac3_float_allocate_sample_buffers;
     }
+#if CONFIG_EAC3_ENCODER
     if (CONFIG_EAC3_ENCODER && s->eac3)
         s->output_frame_header = ff_eac3_output_frame_header;
     else
+#endif
         s->output_frame_header = ac3_output_frame_header;
 
     set_bandwidth(s);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3enc_fixed.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_fixed.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3enc_fixed.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_fixed.c	2017-05-04 13:47:00.000000000 +0300
@@ -31,7 +31,9 @@
 #include "internal.h"
 #include "audiodsp.h"
 #include "ac3enc.h"
+#if CONFIG_EAC3_ENCODER
 #include "eac3enc.h"
+#endif
 
 #define AC3ENC_TYPE AC3ENC_TYPE_AC3_FIXED
 #include "ac3enc_opts_template.c"
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3enc_float.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_float.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3enc_float.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_float.c	2017-05-04 13:47:00.000000000 +0300
@@ -30,7 +30,9 @@
 #include "internal.h"
 #include "audiodsp.h"
 #include "ac3enc.h"
+#if CONFIG_EAC3_ENCODER
 #include "eac3enc.h"
+#endif
 #include "kbdwin.h"
 
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3enc_template.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_template.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3enc_template.c	2017-05-16 15:47:03.722792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3enc_template.c	2017-05-04 13:47:00.000000000 +0300
@@ -34,7 +34,9 @@
 #include "audiodsp.h"
 #include "internal.h"
 #include "ac3enc.h"
+#if CONFIG_EAC3_ENCODER
 #include "eac3enc.h"
+#endif
 
 
 int AC3_NAME(allocate_sample_buffers)(AC3EncodeContext *s)
@@ -314,8 +316,10 @@
         }
     }
 
+#if CONFIG_EAC3_ENCODER
     if (CONFIG_EAC3_ENCODER && s->eac3)
         ff_eac3_set_cpl_states(s);
+#endif
 }
 
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3.h
--- FFmpeg-Plex-Transcoder/libavcodec/ac3.h	2017-05-16 15:47:03.718792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3.h	2017-05-04 13:47:00.000000000 +0300
@@ -27,6 +27,8 @@
 #ifndef AVCODEC_AC3_H
 #define AVCODEC_AC3_H
 
+#include "config.h"
+
 #define AC3_MAX_CODED_FRAME_SIZE 3840 /* in bytes */
 #define AC3_MAX_CHANNELS 7            /**< maximum number of channels, including coupling channel */
 #define CPL_CH 0                      /**< coupling channel index */
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ac3_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/ac3_parser.c	2017-05-16 15:47:03.718792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ac3_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -191,6 +191,7 @@
     AACAC3ParseContext *s = s1->priv_data;
     s->header_size = AC3_HEADER_SIZE;
     s->sync = ac3_sync;
+    s1->flags |= PARSER_FLAG_ONCE;
     return 0;
 }
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/allcodecs.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/allcodecs.c
--- FFmpeg-Plex-Transcoder/libavcodec/allcodecs.c	2017-05-16 15:47:33.754792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/allcodecs.c	2017-05-04 13:47:00.000000000 +0300
@@ -27,7 +27,19 @@
 #include "config.h"
 #include "libavutil/thread.h"
 #include "avcodec.h"
+#include "internal.h"
 #include "version.h"
+#include "libavutil/extlib.h"
+
+static FFLibrary ff_library = {
+    .av_vlog = av_vlog,
+    .av_version_info = av_version_info,
+    .avcodec_version = avcodec_version,
+    .avcodec_register = avcodec_register,
+    .av_register_hwaccel = av_register_hwaccel,
+    .av_register_codec_parser = av_register_codec_parser,
+    .av_hwaccel_next = av_hwaccel_next,
+};
 
 #define REGISTER_HWACCEL(X, x)                                          \
     {                                                                   \
@@ -46,8 +58,9 @@
 #define REGISTER_DECODER(X, x)                                          \
     {                                                                   \
         extern AVCodec ff_##x##_decoder;                                \
-        if (CONFIG_##X##_DECODER)                                       \
+        if (CONFIG_##X##_DECODER) {                                     \
             avcodec_register(&ff_##x##_decoder);                        \
+        }                                                               \
     }
 
 #define REGISTER_ENCDEC(X, x) REGISTER_ENCODER(X, x); REGISTER_DECODER(X, x)
@@ -59,14 +72,22 @@
             av_register_codec_parser(&ff_##x##_parser);                 \
     }
 
+void ff_avcodec_scan_new_things(void)
+{
+    avpriv_load_new_libs(&ff_library);
+}
+
 static void register_all(void)
 {
+    ff_library.is_master = 1;
+
     /* hardware accelerators */
     REGISTER_HWACCEL(H263_VAAPI,        h263_vaapi);
     REGISTER_HWACCEL(H263_VIDEOTOOLBOX, h263_videotoolbox);
     REGISTER_HWACCEL(H264_CUVID,        h264_cuvid);
     REGISTER_HWACCEL(H264_D3D11VA,      h264_d3d11va);
     REGISTER_HWACCEL(H264_DXVA2,        h264_dxva2);
+    REGISTER_HWACCEL(H264_MF,           h264_mf);
     REGISTER_HWACCEL(H264_MEDIACODEC,   h264_mediacodec);
     REGISTER_HWACCEL(H264_MMAL,         h264_mmal);
     REGISTER_HWACCEL(H264_QSV,          h264_qsv);
@@ -79,10 +100,12 @@
     REGISTER_HWACCEL(HEVC_D3D11VA,      hevc_d3d11va);
     REGISTER_HWACCEL(HEVC_DXVA2,        hevc_dxva2);
     REGISTER_HWACCEL(HEVC_MEDIACODEC,   hevc_mediacodec);
+    REGISTER_HWACCEL(HEVC_MF,           hevc_mf);
     REGISTER_HWACCEL(HEVC_QSV,          hevc_qsv);
     REGISTER_HWACCEL(HEVC_VAAPI,        hevc_vaapi);
     REGISTER_HWACCEL(HEVC_VDPAU,        hevc_vdpau);
     REGISTER_HWACCEL(MJPEG_CUVID,       mjpeg_cuvid);
+    REGISTER_HWACCEL(MJPEG_MF,          mjpeg_mf);
     REGISTER_HWACCEL(MPEG1_CUVID,       mpeg1_cuvid);
     REGISTER_HWACCEL(MPEG1_XVMC,        mpeg1_xvmc);
     REGISTER_HWACCEL(MPEG1_VDPAU,       mpeg1_vdpau);
@@ -91,6 +114,7 @@
     REGISTER_HWACCEL(MPEG2_XVMC,        mpeg2_xvmc);
     REGISTER_HWACCEL(MPEG2_D3D11VA,     mpeg2_d3d11va);
     REGISTER_HWACCEL(MPEG2_DXVA2,       mpeg2_dxva2);
+    REGISTER_HWACCEL(MPEG2_MF,          mpeg2_mf);
     REGISTER_HWACCEL(MPEG2_MMAL,        mpeg2_mmal);
     REGISTER_HWACCEL(MPEG2_QSV,         mpeg2_qsv);
     REGISTER_HWACCEL(MPEG2_VAAPI,       mpeg2_vaapi);
@@ -98,15 +122,20 @@
     REGISTER_HWACCEL(MPEG2_VIDEOTOOLBOX, mpeg2_videotoolbox);
     REGISTER_HWACCEL(MPEG4_CUVID,       mpeg4_cuvid);
     REGISTER_HWACCEL(MPEG4_MEDIACODEC,  mpeg4_mediacodec);
+    REGISTER_HWACCEL(MPEG4_MF,          mpeg4_mf);
     REGISTER_HWACCEL(MPEG4_MMAL,        mpeg4_mmal);
     REGISTER_HWACCEL(MPEG4_VAAPI,       mpeg4_vaapi);
     REGISTER_HWACCEL(MPEG4_VDPAU,       mpeg4_vdpau);
     REGISTER_HWACCEL(MPEG4_VIDEOTOOLBOX, mpeg4_videotoolbox);
+    REGISTER_HWACCEL(MSMPEG4V1_MF,      msmpeg4v1_mf);
+    REGISTER_HWACCEL(MSMPEG4V2_MF,      msmpeg4v2_mf);
+    REGISTER_HWACCEL(MSMPEG4V3_MF,      msmpeg4v3_mf);
     REGISTER_HWACCEL(VC1_CUVID,         vc1_cuvid);
     REGISTER_HWACCEL(VC1_D3D11VA,       vc1_d3d11va);
     REGISTER_HWACCEL(VC1_DXVA2,         vc1_dxva2);
     REGISTER_HWACCEL(VC1_VAAPI,         vc1_vaapi);
     REGISTER_HWACCEL(VC1_VDPAU,         vc1_vdpau);
+    REGISTER_HWACCEL(VC1_MF,            vc1_mf);
     REGISTER_HWACCEL(VC1_MMAL,          vc1_mmal);
     REGISTER_HWACCEL(VC1_QSV,           vc1_qsv);
     REGISTER_HWACCEL(VP8_CUVID,         vp8_cuvid);
@@ -117,6 +146,9 @@
     REGISTER_HWACCEL(VP9_DXVA2,         vp9_dxva2);
     REGISTER_HWACCEL(VP9_MEDIACODEC,    vp9_mediacodec);
     REGISTER_HWACCEL(VP9_VAAPI,         vp9_vaapi);
+    REGISTER_HWACCEL(WMV1_MF,           wmv1_mf);
+    REGISTER_HWACCEL(WMV2_MF,           wmv2_mf);
+    REGISTER_HWACCEL(WMV3_MF,           wmv3_mf);
     REGISTER_HWACCEL(WMV3_D3D11VA,      wmv3_d3d11va);
     REGISTER_HWACCEL(WMV3_DXVA2,        wmv3_dxva2);
     REGISTER_HWACCEL(WMV3_VAAPI,        wmv3_vaapi);
@@ -202,6 +234,7 @@
     REGISTER_DECODER(H264,              h264);
     REGISTER_DECODER(H264_CRYSTALHD,    h264_crystalhd);
     REGISTER_DECODER(H264_MEDIACODEC,   h264_mediacodec);
+    REGISTER_DECODER(H264_MEDIACODECNDK,h264_mediacodecndk);
     REGISTER_DECODER(H264_MMAL,         h264_mmal);
     REGISTER_DECODER(H264_QSV,          h264_qsv);
     REGISTER_DECODER(H264_VDA,          h264_vda);
@@ -210,6 +243,7 @@
 #endif
     REGISTER_ENCDEC (HAP,               hap);
     REGISTER_DECODER(HEVC,              hevc);
+    REGISTER_DECODER(HEVC_MEDIACODECNDK,hevc_mediacodecndk);
     REGISTER_DECODER(HEVC_QSV,          hevc_qsv);
     REGISTER_DECODER(HNM4_VIDEO,        hnm4_video);
     REGISTER_DECODER(HQ_HQA,            hq_hqa);
@@ -254,6 +288,7 @@
     REGISTER_DECODER(MPEG_VDPAU,        mpeg_vdpau);
     REGISTER_DECODER(MPEG1_VDPAU,       mpeg1_vdpau);
 #endif
+    REGISTER_DECODER(MPEG2_MEDIACODECNDK, mpeg2_mediacodecndk);
     REGISTER_DECODER(MPEG2_MMAL,        mpeg2_mmal);
     REGISTER_DECODER(MPEG2_CRYSTALHD,   mpeg2_crystalhd);
     REGISTER_DECODER(MPEG2_QSV,         mpeg2_qsv);
@@ -604,6 +639,36 @@
     REGISTER_ENCDEC (PCM_MULAW_AT,      pcm_mulaw_at);
     REGISTER_DECODER(QDMC_AT,           qdmc_at);
     REGISTER_DECODER(QDM2_AT,           qdm2_at);
+
+    REGISTER_ENCDEC (AAC_MF,            aac_mf);
+    REGISTER_ENCDEC (AC3_MF,            ac3_mf);
+    REGISTER_DECODER(EAC3_MF,           eac3_mf);
+    REGISTER_ENCDEC (H264_MF,           h264_mf);
+    REGISTER_ENCDEC (HEVC_MF,           hevc_mf);
+    REGISTER_DECODER(MJPEG_MF,          mjpeg_mf);
+    REGISTER_DECODER(MP1_MF,            mp1_mf);
+    REGISTER_DECODER(MP2_MF,            mp2_mf);
+    REGISTER_ENCDEC (MP3_MF,            mp3_mf);
+    REGISTER_DECODER(MPEG2_MF,          mpeg2_mf);
+    REGISTER_DECODER(MPEG4_MF,          mpeg4_mf);
+    REGISTER_DECODER(MSMPEG4V1_MF,      msmpeg4v1_mf);
+    REGISTER_DECODER(MSMPEG4V2_MF,      msmpeg4v2_mf);
+    REGISTER_DECODER(MSMPEG4V3_MF,      msmpeg4v3_mf);
+    REGISTER_DECODER(VC1_MF,            vc1_mf);
+    REGISTER_DECODER(WMALOSSLESS_MF,    wmalossless_mf);
+    REGISTER_DECODER(WMAPRO_MF,         wmapro_mf);
+    REGISTER_DECODER(WMAV1_MF,          wmav1_mf);
+    REGISTER_DECODER(WMAV2_MF,          wmav2_mf);
+    REGISTER_DECODER(WMAVOICE_MF,       wmavoice_mf);
+    REGISTER_DECODER(WMV1_MF,           wmv1_mf);
+    REGISTER_DECODER(WMV2_MF,           wmv2_mf);
+    REGISTER_DECODER(WMV3_MF,           wmv3_mf);
+
+    REGISTER_ENCDEC (AC3_EAE,           ac3_eae);
+    REGISTER_ENCDEC (EAC3_EAE,          eac3_eae);
+    REGISTER_DECODER(TRUEHD_EAE,        truehd_eae);
+    REGISTER_DECODER(MLP_EAE,           mlp_eae);
+
     REGISTER_DECODER(LIBCELT,           libcelt);
     REGISTER_ENCDEC (LIBFDK_AAC,        libfdk_aac);
     REGISTER_ENCDEC (LIBGSM,            libgsm);
@@ -643,6 +708,7 @@
      * above is available */
     REGISTER_ENCDEC (LIBOPENH264,       libopenh264);
     REGISTER_DECODER(H264_CUVID,        h264_cuvid);
+    REGISTER_ENCODER(H264_MEDIACODECNDK,h264_mediacodecndk);
     REGISTER_ENCODER(H264_NVENC,        h264_nvenc);
     REGISTER_ENCODER(H264_OMX,          h264_omx);
     REGISTER_ENCODER(H264_QSV,          h264_qsv);
@@ -716,6 +782,8 @@
     REGISTER_PARSER(VP8,                vp8);
     REGISTER_PARSER(VP9,                vp9);
     REGISTER_PARSER(XMA,                xma);
+
+    ff_avcodec_scan_new_things();
 }
 
 void avcodec_register_all(void)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/arm/h264cmc_neon.S /home/klogg/Downloads/ffmpeg-plex/libavcodec/arm/h264cmc_neon.S
--- FFmpeg-Plex-Transcoder/libavcodec/arm/h264cmc_neon.S	2017-05-16 15:47:03.738792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/arm/h264cmc_neon.S	2017-05-04 13:47:00.000000000 +0300
@@ -441,7 +441,6 @@
         h264_chroma_mc2 put
         h264_chroma_mc2 avg
 
-#if CONFIG_RV40_DECODER
 const   rv40bias
         .short           0, 16, 32, 16
         .short          32, 28, 32, 28
@@ -453,11 +452,8 @@
         h264_chroma_mc8 avg, rv40
         h264_chroma_mc4 put, rv40
         h264_chroma_mc4 avg, rv40
-#endif
 
-#if CONFIG_VC1DSP
         h264_chroma_mc8 put, vc1
         h264_chroma_mc8 avg, vc1
         h264_chroma_mc4 put, vc1
         h264_chroma_mc4 avg, vc1
-#endif
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/arm/Makefile /home/klogg/Downloads/ffmpeg-plex/libavcodec/arm/Makefile
--- FFmpeg-Plex-Transcoder/libavcodec/arm/Makefile	2017-05-16 15:47:03.734792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/arm/Makefile	2017-05-04 13:47:00.000000000 +0300
@@ -41,6 +41,7 @@
 OBJS-$(CONFIG_DCA_DECODER)             += arm/synth_filter_init_arm.o
 OBJS-$(CONFIG_HEVC_DECODER)            += arm/hevcdsp_init_arm.o
 OBJS-$(CONFIG_MLP_DECODER)             += arm/mlpdsp_init_arm.o
+OBJS-$(CONFIG_TRUEHD_DECODER)          += arm/mlpdsp_init_arm.o
 OBJS-$(CONFIG_RV40_DECODER)            += arm/rv40dsp_init_arm.o
 OBJS-$(CONFIG_VORBIS_DECODER)          += arm/vorbisdsp_init_arm.o
 OBJS-$(CONFIG_VP6_DECODER)             += arm/vp6dsp_init_arm.o
@@ -60,6 +61,7 @@
 
 # decoders/encoders
 ARMV5TE-OBJS-$(CONFIG_MLP_DECODER)     += arm/mlpdsp_armv5te.o
+ARMV5TE-OBJS-$(CONFIG_TRUEHD_DECODER)  += arm/mlpdsp_armv5te.o
 
 
 # ARMv6 optimizations
@@ -81,6 +83,7 @@
 
 # decoders/encoders
 ARMV6-OBJS-$(CONFIG_MLP_DECODER)       += arm/mlpdsp_armv6.o
+ARMV6-OBJS-$(CONFIG_TRUEHD_DECODER)    += arm/mlpdsp_armv6.o
 
 
 # VFP optimizations
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/ass_split.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/ass_split.c
--- FFmpeg-Plex-Transcoder/libavcodec/ass_split.c	2017-05-16 15:47:03.758792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/ass_split.c	2017-05-04 13:47:00.000000000 +0300
@@ -495,20 +495,30 @@
     const char *text = NULL;
     char new_line[2];
     int text_len = 0;
+    int drawing = 0; //PLEX
 
     while (buf && *buf) {
         if (text && callbacks->text &&
-            (sscanf(buf, "\\%1[nN]", new_line) == 1 ||
-             !strncmp(buf, "{\\", 2))) {
+//PLEX
+            (sscanf(buf, "\\%1[nNh]", new_line) == 1 ||
+             *buf == '{') && !drawing) {
+//PLEX
             callbacks->text(priv, text, text_len);
             text = NULL;
         }
-        if (sscanf(buf, "\\%1[nN]", new_line) == 1) {
+//PLEX
+        if (sscanf(buf, "\\%1[h]", new_line) == 1) {
+            callbacks->text(priv, " ", 1);
+            buf += 2;
+        } else if (sscanf(buf, "\\%1[nN]", new_line) == 1) {
+//PLEX
             if (callbacks->new_line)
                 callbacks->new_line(priv, new_line[0] == 'N');
             buf += 2;
-        } else if (!strncmp(buf, "{\\", 2)) {
-            buf++;
+//PLEX
+        } else if (*buf == '{') {
+            buf += strcspn(buf, "\\}");  /* skip comments */;
+//PLEX
             while (*buf == '\\') {
                 char style[2], c[2], sep[2], c_num[2] = "0", tmp[128] = {0};
                 unsigned int color = 0xFFFFFFFF;
@@ -519,6 +529,10 @@
                     len += close != -1;
                     if (callbacks->style)
                         callbacks->style(priv, style[0], close);
+//PLEX
+                } else if (sscanf(buf, "\\p%u%1[\\}]%n", &size, sep, &len) > 1) {
+                    drawing = (size > 0);
+//PLEX
                 } else if (sscanf(buf, "\\c%1[\\}]%n", sep, &len) > 0 ||
                            sscanf(buf, "\\c&H%X&%1[\\}]%n", &color, sep, &len) > 1 ||
                            sscanf(buf, "\\%1[1234]c%1[\\}]%n", c_num, sep, &len) > 1 ||
@@ -567,7 +581,7 @@
                 buf += len - 1;
             }
             if (*buf++ != '}')
-                return AVERROR_INVALIDDATA;
+                goto end; //PLEX
         } else {
             if (!text) {
                 text = buf;
@@ -577,7 +591,8 @@
             buf++;
         }
     }
-    if (text && callbacks->text)
+end: //PLEX
+    if (text && callbacks->text && !drawing) //PLEX
         callbacks->text(priv, text, text_len);
     if (callbacks->end)
         callbacks->end(priv);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/audiotoolboxdec.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/audiotoolboxdec.c
--- FFmpeg-Plex-Transcoder/libavcodec/audiotoolboxdec.c	2017-05-16 15:47:03.762792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/audiotoolboxdec.c	2017-05-04 13:47:00.000000000 +0300
@@ -29,6 +29,7 @@
 #include "internal.h"
 #include "mpegaudiodecheader.h"
 #include "libavutil/avassert.h"
+#include "libavutil/crc.h"
 #include "libavutil/opt.h"
 #include "libavutil/log.h"
 
@@ -58,6 +59,15 @@
 {
     switch (codec) {
     case AV_CODEC_ID_AAC:
+        if (profile == FF_PROFILE_AAC_HE)
+            return kAudioFormatMPEG4AAC_HE;
+        else if (profile == FF_PROFILE_AAC_HE_V2)
+            return kAudioFormatMPEG4AAC_HE_V2;
+        else if (profile == FF_PROFILE_AAC_LD)
+            return kAudioFormatMPEG4AAC_LD;
+        else if (profile == FF_PROFILE_AAC_ELD)
+            return kAudioFormatMPEG4AAC_ELD;
+        else
         return kAudioFormatMPEG4AAC;
     case AV_CODEC_ID_AC3:
         return kAudioFormatAC3;
@@ -102,7 +112,7 @@
     else if (label <= kAudioChannelLabel_RightSurround)
         return label + 4;
     else if (label <= kAudioChannelLabel_CenterSurround)
-        return label + 1;
+        return label - 1;
     else if (label <= kAudioChannelLabel_RightSurroundDirect)
         return label + 23;
     else if (label <= kAudioChannelLabel_TopBackRight)
@@ -164,6 +174,13 @@
     if (!AudioConverterGetProperty(at->converter,
                                    kAudioConverterCurrentInputStreamDescription,
                                    &size, &format)) {
+        if (avctx->codec_id == AV_CODEC_ID_AAC) {
+            if ((avctx->profile == FF_PROFILE_AAC_HE || avctx->profile == FF_PROFILE_AAC_HE_V2) &&
+                avctx->sample_rate == format.mSampleRate * 2)
+                format.mSampleRate = avctx->sample_rate;
+            if (avctx->profile == FF_PROFILE_AAC_HE_V2)
+                format.mChannelsPerFrame = 2;
+        }
         if (format.mSampleRate)
             avctx->sample_rate = format.mSampleRate;
         avctx->channels = format.mChannelsPerFrame;
@@ -333,6 +350,18 @@
             av_log(avctx, AV_LOG_ERROR, "AudioToolbox header-parse error: %i\n", (int)status);
             return AVERROR_UNKNOWN;
         }
+
+        if (avctx->codec_id == AV_CODEC_ID_AAC) {
+            if ((avctx->profile == FF_PROFILE_AAC_HE || avctx->profile == FF_PROFILE_AAC_HE_V2) &&
+                avctx->sample_rate == in_format.mSampleRate * 2) {
+                in_format.mSampleRate = avctx->sample_rate;
+                in_format.mFramesPerPacket *= 2;
+            }
+            if (avctx->profile == FF_PROFILE_AAC_HE_V2)
+                in_format.mChannelsPerFrame = 2;
+
+            in_format.mFormatID = ffat_get_format_id(avctx->codec_id, avctx->profile);
+        }
 #if CONFIG_MP1_AT_DECODER || CONFIG_MP2_AT_DECODER || CONFIG_MP3_AT_DECODER
     } else if (pkt && pkt->size >= 4 &&
                (avctx->codec_id == AV_CODEC_ID_MP1 ||
@@ -401,10 +430,6 @@
     ATDecodeContext *at = avctx->priv_data;
     at->extradata = avctx->extradata;
     at->extradata_size = avctx->extradata_size;
-
-    if ((avctx->channels && avctx->sample_rate) || ffat_usable_extradata(avctx))
-        return ffat_create_decoder(avctx, NULL);
-    else
         return 0;
 }
 
@@ -546,6 +571,31 @@
 
     out_buffers.mBuffers[0].mData = at->decoded_data;
 
+#if CONFIG_AC3_AT_DECODER || CONFIG_EAC3_AT_DECODER
+    if (at->new_in_pkt.size >= 7 &&
+        (avctx->codec_id == AV_CODEC_ID_AC3 ||
+         avctx->codec_id == AV_CODEC_ID_EAC3)) {
+        AC3HeaderInfo hdr, *phdr = &hdr;
+        GetBitContext gbc;
+        init_get_bits(&gbc, avpkt->data, avpkt->size);
+        if (avpriv_ac3_parse_header(&gbc, &phdr) < 0) {
+            ret = AVERROR_INVALIDDATA;
+        } else {
+            if (avpkt->size > hdr.frame_size) {
+                av_log(avctx, AV_LOG_WARNING, "Packet size %i > frame size %i; correcting\n",
+                       avpkt->size, hdr.frame_size);
+                at->new_in_pkt.size = hdr.frame_size;
+            }
+            /* check for crc mismatch */
+            if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, avpkt->data + 2,
+                       at->new_in_pkt.size - 2)) {
+                ret = AVERROR_INVALIDDATA;
+            }
+        }
+    }
+#endif
+
+    if (ret >= 0)
     ret = AudioConverterFillComplexBuffer(at->converter, ffat_decode_callback, avctx,
                                           &frame->nb_samples, &out_buffers, NULL);
     if ((!ret || ret == 1) && frame->nb_samples) {
@@ -590,6 +640,36 @@
     return 0;
 }
 
+static int ffat_probe(struct AVCodec *codec)
+{
+    OSStatus status;
+    AudioConverterRef converter;
+
+    AudioStreamBasicDescription in_format = {
+        .mSampleRate = codec->id == AV_CODEC_ID_AMR_NB ? 8000 : 44100,
+        .mFormatID = ffat_get_format_id(codec->id, 0),
+        .mBytesPerPacket = 0,
+        .mFramesPerPacket = codec->id == AV_CODEC_ID_ADPCM_IMA_QT ? 64 : 0,
+        .mChannelsPerFrame = 2,
+    };
+    AudioStreamBasicDescription out_format = {
+        .mSampleRate = in_format.mSampleRate,
+        .mFormatID = kAudioFormatLinearPCM,
+        .mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked,
+        .mFramesPerPacket = 1,
+        .mChannelsPerFrame = 2,
+        .mBitsPerChannel = 16,
+    };
+
+    status = AudioConverterNew(&in_format, &out_format, &converter);
+
+    if (status != 0)
+        return AVERROR(ENOSYS);
+
+    AudioConverterDispose(converter);
+    return 0;
+}
+
 #define FFAT_DEC_CLASS(NAME) \
     static const AVClass ffat_##NAME##_dec_class = { \
         .class_name = "at_" #NAME "_dec", \
@@ -604,6 +684,7 @@
         .type           = AVMEDIA_TYPE_AUDIO, \
         .id             = ID, \
         .priv_data_size = sizeof(ATDecodeContext), \
+        .probe          = ffat_probe, \
         .init           = ffat_init_decoder, \
         .close          = ffat_close_decoder, \
         .decode         = ffat_decode, \
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/audiotoolboxenc.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/audiotoolboxenc.c
--- FFmpeg-Plex-Transcoder/libavcodec/audiotoolboxenc.c	2017-05-16 15:47:03.762792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/audiotoolboxenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -157,7 +157,7 @@
     else if (map <= AV_CH_BACK_RIGHT)
         return channel + 29;
     else if (map <= AV_CH_BACK_CENTER)
-        return channel - 1;
+        return channel + 1;
     else if (map <= AV_CH_SIDE_RIGHT)
         return channel - 4;
     else if (map <= AV_CH_TOP_BACK_RIGHT)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/avcodec.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/avcodec.h
--- FFmpeg-Plex-Transcoder/libavcodec/avcodec.h	2017-05-16 15:47:33.754792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/avcodec.h	2017-05-04 13:47:00.000000000 +0300
@@ -3524,6 +3524,14 @@
      */
     uint16_t *chroma_intra_matrix;
 
+//PLEX
+    /**
+     * Whether or not an H.264 scaling matrix is present
+     * - decoding: Set by h264 decoder
+     */
+    int scaling_matrix_present;
+//PLEX
+
     /**
      * dump format separator.
      * can be ", " or "\n      " or anything else
@@ -3786,6 +3794,11 @@
      * See FF_CODEC_CAP_* in internal.h
      */
     int caps_internal;
+    /**
+     * Check whether the codec is available (useful for system codecs). If it's
+     * not, registering the codec will fail and not add it to the codec list.
+     */
+    int (*probe)(struct AVCodec *codec);
 } AVCodec;
 
 int av_codec_get_max_lowres(const AVCodec *codec);
@@ -5110,6 +5123,8 @@
 #define PARSER_FLAG_FETCHED_OFFSET            0x0004
 #define PARSER_FLAG_USE_CODEC_TS              0x1000
 
+#define PARSER_FLAG_SKIP                      0x800000
+
     int64_t offset;      ///< byte offset from starting packet start
     int64_t cur_frame_end[AV_PARSER_PTS_NB];
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/bitstream_filters.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/bitstream_filters.c
--- FFmpeg-Plex-Transcoder/libavcodec/bitstream_filters.c	2017-05-16 15:47:33.754792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/bitstream_filters.c	2017-05-04 13:47:00.000000000 +0300
@@ -29,6 +29,7 @@
 extern const AVBitStreamFilter ff_dump_extradata_bsf;
 extern const AVBitStreamFilter ff_dca_core_bsf;
 extern const AVBitStreamFilter ff_extract_extradata_bsf;
+extern const AVBitStreamFilter ff_framedrop_bsf;
 extern const AVBitStreamFilter ff_h264_mp4toannexb_bsf;
 extern const AVBitStreamFilter ff_hevc_mp4toannexb_bsf;
 extern const AVBitStreamFilter ff_imx_dump_header_bsf;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dca_core.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_core.c
--- FFmpeg-Plex-Transcoder/libavcodec/dca_core.c	2017-05-16 15:47:03.786792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_core.c	2017-05-04 13:47:00.000000000 +0300
@@ -75,19 +75,6 @@
     { DCA_SPEAKER_C, DCA_SPEAKER_L, DCA_SPEAKER_R,  DCA_SPEAKER_Ls, DCA_SPEAKER_Rs }
 };
 
-static const uint8_t audio_mode_ch_mask[AMODE_COUNT] = {
-    DCA_SPEAKER_LAYOUT_MONO,
-    DCA_SPEAKER_LAYOUT_STEREO,
-    DCA_SPEAKER_LAYOUT_STEREO,
-    DCA_SPEAKER_LAYOUT_STEREO,
-    DCA_SPEAKER_LAYOUT_STEREO,
-    DCA_SPEAKER_LAYOUT_3_0,
-    DCA_SPEAKER_LAYOUT_2_1,
-    DCA_SPEAKER_LAYOUT_3_1,
-    DCA_SPEAKER_LAYOUT_2_2,
-    DCA_SPEAKER_LAYOUT_5POINT0
-};
-
 static const uint8_t block_code_nbits[7] = {
     7, 10, 12, 13, 15, 17, 19
 };
@@ -242,7 +229,7 @@
         }
         av_assert1(s->nchannels <= DCA_CHANNELS - 2);
 
-        s->ch_mask = audio_mode_ch_mask[s->audio_mode];
+        s->ch_mask = ff_dca_audio_mode_ch_mask[s->audio_mode];
 
         // Add LFE channel if present
         if (s->lfe_present)
@@ -1955,7 +1942,7 @@
             if (avctx->err_recognition & AV_EF_EXPLODE)
                 return ret;
             s->nchannels = ff_dca_channels[s->audio_mode];
-            s->ch_mask = audio_mode_ch_mask[s->audio_mode];
+            s->ch_mask = ff_dca_audio_mode_ch_mask[s->audio_mode];
             if (s->lfe_present)
                 s->ch_mask |= DCA_SPEAKER_MASK_LFE1;
         } else {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dcadata.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadata.c
--- FFmpeg-Plex-Transcoder/libavcodec/dcadata.c	2017-05-16 15:47:03.790792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadata.c	2017-05-04 13:47:00.000000000 +0300
@@ -50,6 +50,19 @@
     1, 2, 2, 3, 3, 4, 4, 0
 };
 
+const uint8_t ff_dca_audio_mode_ch_mask[] = {
+    DCA_SPEAKER_LAYOUT_MONO,
+    DCA_SPEAKER_LAYOUT_STEREO,
+    DCA_SPEAKER_LAYOUT_STEREO,
+    DCA_SPEAKER_LAYOUT_STEREO,
+    DCA_SPEAKER_LAYOUT_STEREO,
+    DCA_SPEAKER_LAYOUT_3_0,
+    DCA_SPEAKER_LAYOUT_2_1,
+    DCA_SPEAKER_LAYOUT_3_1,
+    DCA_SPEAKER_LAYOUT_2_2,
+    DCA_SPEAKER_LAYOUT_5POINT0
+};
+
 const uint8_t ff_dca_quant_index_sel_nbits[DCA_CODE_BOOKS] = {
     1, 2, 2, 2, 2, 3, 3, 3, 3, 3
 };
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dcadata.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadata.h
--- FFmpeg-Plex-Transcoder/libavcodec/dcadata.h	2017-05-16 15:47:03.790792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadata.h	2017-05-04 13:47:00.000000000 +0300
@@ -33,6 +33,8 @@
 
 extern const uint8_t ff_dca_dmix_primary_nch[8];
 
+extern const uint8_t ff_dca_audio_mode_ch_mask[];
+
 extern const uint8_t ff_dca_quant_index_sel_nbits[DCA_CODE_BOOKS];
 extern const uint8_t ff_dca_quant_index_group_size[DCA_CODE_BOOKS];
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dcadec.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadec.c
--- FFmpeg-Plex-Transcoder/libavcodec/dcadec.c	2017-05-16 15:47:03.790792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadec.c	2017-05-04 13:47:00.000000000 +0300
@@ -141,6 +141,7 @@
     }
 }
 
+#if CONFIG_DCA_DECODER
 static int dcadec_decode_frame(AVCodecContext *avctx, void *data,
                                int *got_frame_ptr, AVPacket *avpkt)
 {
@@ -148,7 +149,7 @@
     AVFrame *frame = data;
     uint8_t *input = avpkt->data;
     int input_size = avpkt->size;
-    int i, ret, prev_packet = s->packet;
+    int i, ret;//PLEX, prev_packet = s->packet;
     uint32_t mrk;
 
     if (input_size < MIN_PACKET_SIZE || input_size > MAX_PACKET_SIZE) {
@@ -194,6 +195,7 @@
         }
     }
 
+#if 0 //PLEX
     if (!s->core_only) {
         DCAExssAsset *asset = NULL;
 
@@ -276,6 +278,9 @@
             if ((ret = ff_dca_core_filter_frame(&s->core, frame)) < 0)
                 return ret;
         }
+#else //PLEX
+    if (0) {
+#endif //PLEX
     } else if (s->packet & DCA_PACKET_CORE) {
         if ((ret = ff_dca_core_filter_frame(&s->core, frame)) < 0)
             return ret;
@@ -298,8 +303,10 @@
     DCAContext *s = avctx->priv_data;
 
     ff_dca_core_flush(&s->core);
+#if 0 //PLEX
     ff_dca_xll_flush(&s->xll);
     ff_dca_lbr_flush(&s->lbr);
+#endif //PLEX
 
     s->packet &= DCA_PACKET_MASK;
 }
@@ -309,8 +316,10 @@
     DCAContext *s = avctx->priv_data;
 
     ff_dca_core_close(&s->core);
+#if 0 //PLEX
     ff_dca_xll_close(&s->xll);
     ff_dca_lbr_close(&s->lbr);
+#endif
 
     av_freep(&s->buffer);
     s->buffer_size = 0;
@@ -333,8 +342,10 @@
     if (ff_dca_core_init(&s->core) < 0)
         return AVERROR(ENOMEM);
 
+#if 0 //PLEX
     if (ff_dca_lbr_init(&s->lbr) < 0)
         return AVERROR(ENOMEM);
+#endif //PLEX
 
     ff_dcadsp_init(&s->dcadsp);
     s->core.dcadsp = &s->dcadsp;
@@ -391,10 +402,11 @@
     .decode         = dcadec_decode_frame,
     .close          = dcadec_close,
     .flush          = dcadec_flush,
-    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
+    .capabilities   = AV_CODEC_CAP_DR1, // PLEX: removed AV_CODEC_CAP_CHANNEL_CONF
     .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P, AV_SAMPLE_FMT_S32P,
                                                       AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE },
     .priv_class     = &dcadec_class,
     .profiles       = NULL_IF_CONFIG_SMALL(ff_dca_profiles),
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
+#endif
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dcadec.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadec.h
--- FFmpeg-Plex-Transcoder/libavcodec/dcadec.h	2017-05-16 15:47:03.790792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dcadec.h	2017-05-04 13:47:00.000000000 +0300
@@ -75,7 +75,12 @@
 static inline int ff_dca_check_crc(AVCodecContext *avctx, GetBitContext *s,
                                    int p1, int p2)
 {
-    DCAContext *dca = avctx->priv_data;
+    DCAContext *dca;
+
+    if (!avctx || !avctx->priv_data)
+        return 0;
+
+    dca = avctx->priv_data;
 
     if (!(avctx->err_recognition & (AV_EF_CRCCHECK | AV_EF_CAREFUL)))
         return 0;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dca_lbr.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_lbr.c
--- FFmpeg-Plex-Transcoder/libavcodec/dca_lbr.c	2017-05-16 15:47:03.786792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_lbr.c	2017-05-04 13:47:00.000000000 +0300
@@ -1379,6 +1379,7 @@
     return 0;
 }
 
+#if 0
 /**
  * Reconstruct high-frequency resolution grid from first and third grids
  */
@@ -1771,6 +1772,7 @@
 
     return 0;
 }
+#endif
 
 av_cold void ff_dca_lbr_flush(DCALbrDecoder *s)
 {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dca_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/dca_parser.c	2017-05-16 15:47:03.786792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -23,10 +23,20 @@
  */
 
 #include "dca.h"
+#include "dcadata.h"
+#include "dca_core.h"
 #include "dca_exss.h"
+#include "dca_xll.h"
 #include "dca_syncwords.h"
 #include "get_bits.h"
 #include "parser.h"
+#include "libavutil/crc.h"
+
+enum ExtAudioType {
+    EXT_AUDIO_XCH   = 0,
+    EXT_AUDIO_X96   = 2,
+    EXT_AUDIO_XXCH  = 6
+};
 
 typedef struct DCAParseContext {
     ParseContext pc;
@@ -183,19 +193,87 @@
 {
     DCAParseContext *pc1 = s->priv_data;
 
+    s->flags |= PARSER_FLAG_ONCE; //PLEX
+
     pc1->lastmarker = 0;
     pc1->sr_code = -1;
     return 0;
 }
 
-static int dca_parse_params(DCAParseContext *pc1, const uint8_t *buf,
-                            int buf_size, int *duration, int *sample_rate)
+static int64_t get_channel_layout(int dca_mask)
+{
+    static const uint8_t dca2wav_norm[28] = {
+         2,  0, 1, 9, 10,  3,  8,  4,  5,  9, 10, 6, 7, 12,
+        13, 14, 3, 6,  7, 11, 12, 14, 16, 15, 17, 8, 4,  5,
+    };
+
+    static const uint8_t dca2wav_wide[28] = {
+         2,  0, 1, 4,  5,  3,  8,  4,  5,  9, 10, 6, 7, 12,
+        13, 14, 3, 9, 10, 11, 12, 14, 16, 15, 17, 8, 4,  5,
+    };
+
+    int dca_ch;
+    int wav_mask = 0;
+    const uint8_t *dca2wav;
+    if (dca_mask == DCA_SPEAKER_LAYOUT_7POINT0_WIDE ||
+        dca_mask == DCA_SPEAKER_LAYOUT_7POINT1_WIDE)
+        dca2wav = dca2wav_wide;
+    else
+        dca2wav = dca2wav_norm;
+    for (dca_ch = 0; dca_ch < 28; dca_ch++) {
+        if (dca_mask & (1 << dca_ch)) {
+            int wav_ch = dca2wav[dca_ch];
+            wav_mask |= 1 << wav_ch;
+        }
+    }
+    return wav_mask;
+}
+
+static void parse_xxch_frame(GetBitContext *gb, int *mask)
+{
+    int xxch_mask_nbits, nchannels, header_size;
+
+    // XXCH sync word
+    if (get_bits_long(gb, 32) != DCA_SYNCWORD_XXCH)
+        return;
+
+    header_size = get_bits(gb, 6) + 1;
+    if (header_size <= 6)
+        return;
+
+    // CRC presence flag for channel set header
+    skip_bits1(gb);
+
+    // Number of bits for loudspeaker mask
+    xxch_mask_nbits = get_bits(gb, 5) + 1;
+    if (xxch_mask_nbits <= DCA_SPEAKER_Cs)
+        return;
+
+    // XXCH frame header length
+    skip_bits_long(gb, header_size * 8 - (32 + 6 + 1 + 5));
+
+    // Channel set header length
+    skip_bits(gb, 7);
+
+    // Number of channels in a channel set
+    nchannels = get_bits(gb, 3) + 1;
+    if (nchannels > DCA_XXCH_CHANNELS_MAX)
+        return;
+
+    // Loudspeaker layout mask
+    *mask |= get_bits_long(gb, xxch_mask_nbits - DCA_SPEAKER_Cs) << DCA_SPEAKER_Cs;
+}
+
+static int dca_parse_params(DCAParseContext *pc1, AVCodecContext *avctx,
+                            const uint8_t *buf, int buf_size, int *duration,
+                            int *sample_rate)
 {
     GetBitContext gb;
     uint8_t hdr[12 + AV_INPUT_BUFFER_PADDING_SIZE] = { 0 };
-    int ret, sample_blocks;
+    int ret, sample_blocks, audio_mode, ch_mask, frame_size;
+    int ext_audio_type, ext_audio_present;
 
-    if (buf_size < 12)
+    if (buf_size < 16)
         return AVERROR_INVALIDDATA;
 
     if (AV_RB32(buf) == DCA_SYNCWORD_SUBSTREAM) {
@@ -225,7 +303,7 @@
 
             *sample_rate = ff_dca_sampling_freqs[pc1->sr_code];
             *duration = 1024 << ff_dca_freq_ranges[pc1->sr_code];
-            return 0;
+            goto parse_full;
         }
 
         if (asset->extension_mask & DCA_EXSS_XLL) {
@@ -249,7 +327,7 @@
 
             *sample_rate = asset->max_sample_rate;
             *duration = (1 + (*sample_rate > 96000)) << nsamples_log2;
-            return 0;
+            goto parse_full;
         }
 
         return AVERROR_INVALIDDATA;
@@ -258,7 +336,7 @@
     if ((ret = avpriv_dca_convert_bitstream(buf, 12, hdr, 12)) < 0)
         return ret;
 
-    init_get_bits(&gb, hdr, 96);
+    init_get_bits(&gb, hdr, 16 * 8);
 
     skip_bits_long(&gb, 39);
     sample_blocks = get_bits(&gb, 7) + 1;
@@ -266,11 +344,203 @@
         return AVERROR_INVALIDDATA;
     *duration = 256 * (sample_blocks / 8);
 
-    skip_bits(&gb, 20);
-    *sample_rate = avpriv_dca_sample_rates[get_bits(&gb, 4)];
+    pc1->framesize = get_bits(&gb, 14) + 1;
+    if (pc1->framesize < 95)
+        return AVERROR_INVALIDDATA;
+    audio_mode   = get_bits(&gb, 6);
+    pc1->sr_code = get_bits(&gb, 4);
+    *sample_rate = avpriv_dca_sample_rates[pc1->sr_code];
     if (*sample_rate == 0)
         return AVERROR_INVALIDDATA;
 
+    // Transmission bit rate
+    avctx->bit_rate = ff_dca_bit_rates[get_bits(&gb, 5)];
+
+    // Additional flags
+    skip_bits(&gb, 5);
+
+    // Extension audio
+    ext_audio_type = get_bits(&gb, 3);
+    ext_audio_present = get_bits1(&gb);
+
+    // Audio sync word insertion flag
+    skip_bits(&gb, 1);
+
+    ch_mask = ff_dca_audio_mode_ch_mask[audio_mode];
+    // Low frequency effects flag
+    if (get_bits(&gb, 2))
+        ch_mask |= DCA_SPEAKER_MASK_LFE1;
+
+    frame_size = FFALIGN(pc1->framesize, 4);
+
+parse_full:
+    if ((!avctx->channel_layout || !avctx->channels || !avctx->sample_rate)) {
+        const AVCRC *crctab = av_crc_get_table(AV_CRC_16_CCITT);
+        int xch_pos = 0, x96_pos = 0, xxch_pos = 0, i;
+        uint32_t mrk = AV_RB32(buf);
+        uint8_t *bebuf = NULL;
+        const uint8_t *input = buf;
+        int input_size = buf_size;
+        DCAExssAsset *asset = &pc1->exss.assets[0];
+        if (mrk != DCA_SYNCWORD_CORE_BE && mrk != DCA_SYNCWORD_SUBSTREAM) {
+            if (!(bebuf = av_malloc(buf_size)))
+                goto fail;
+            if ((ret = avpriv_dca_convert_bitstream(buf, buf_size, bebuf, buf_size)) < 0)
+                goto fail;
+            input = bebuf;
+        }
+
+        if ((ret = init_get_bits8(&gb, input, buf_size)) < 0)
+            goto fail;
+
+        if (AV_RB32(input) == DCA_SYNCWORD_CORE_BE) {
+            if (ext_audio_present) {
+                int sync_pos = FFMIN(frame_size / 4, gb.size_in_bits / 32) - 1;
+                int last_pos = get_bits_count(&gb) / 32;
+                int size, dist;
+                switch (ext_audio_type) {
+                case EXT_AUDIO_XCH:
+                    if (avctx->request_channel_layout)
+                        break;
+
+                    // The distance between XCH sync word and end of the core frame
+                    // must be equal to XCH frame size. Off by one error is allowed for
+                    // compatibility with legacy bitstreams. Minimum XCH frame size is
+                    // 96 bytes. AMODE and PCHS are further checked to reduce
+                    // probability of alias sync detection.
+                    for (; sync_pos >= last_pos; sync_pos--) {
+                        if (AV_RB32(gb.buffer + sync_pos * 4) == DCA_SYNCWORD_XCH) {
+                            gb.index = (sync_pos + 1) * 32;
+                            size = get_bits(&gb, 10) + 1;
+                            dist = frame_size - sync_pos * 4;
+                            if (size >= 96
+                                && (size == dist || size - 1 == dist)
+                                && get_bits(&gb, 7) == 0x08) {
+                                xch_pos = get_bits_count(&gb);
+                                break;
+                            }
+                        }
+                    }
+                    break;
+
+                case EXT_AUDIO_X96:
+                    // The distance between X96 sync word and end of the core frame
+                    // must be equal to X96 frame size. Minimum X96 frame size is 96
+                    // bytes.
+                    for (; sync_pos >= last_pos; sync_pos--) {
+                        if (AV_RB32(gb.buffer + sync_pos * 4) == DCA_SYNCWORD_X96) {
+                            gb.index = (sync_pos + 1) * 32;
+                            size = get_bits(&gb, 12) + 1;
+                            dist = frame_size - sync_pos * 4;
+                            if (size >= 96 && size == dist) {
+                                x96_pos = get_bits_count(&gb);
+                                break;
+                            }
+                        }
+                    }
+                    break;
+
+                case EXT_AUDIO_XXCH:
+                    if (avctx->request_channel_layout)
+                        break;
+
+                    // XXCH frame header CRC must be valid. Minimum XXCH frame header
+                    // size is 11 bytes.
+                    for (; sync_pos >= last_pos; sync_pos--) {
+                        if (AV_RB32(gb.buffer + sync_pos * 4) == DCA_SYNCWORD_XXCH) {
+                            gb.index = (sync_pos + 1) * 32;
+                            size = get_bits(&gb, 6) + 1;
+                            dist = gb.size_in_bits / 8 - sync_pos * 4;
+                            if (size >= 11 && size <= dist &&
+                                !av_crc(crctab, 0xffff, gb.buffer +
+                                        (sync_pos + 1) * 4, size - 4)) {
+                                xxch_pos = sync_pos * 32;
+                                break;
+                            }
+                        }
+                    }
+                    break;
+                }
+            }
+            if (input_size - 4 > frame_size) {
+                input      += frame_size;
+                input_size -= frame_size;
+            }
+        }
+        if (AV_RB32(input) == DCA_SYNCWORD_SUBSTREAM) {
+            if ((ret = ff_dca_exss_parse(&pc1->exss, (uint8_t*)input, input_size)) < 0)
+                goto fail;
+        }
+
+        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;
+
+        if (asset && asset->extension_mask & DCA_EXSS_XLL) {
+            DCAXllChSet *c;
+            DCAXllDecoder xll = {0};
+            if ((ret = ff_dca_xll_parse(&xll, (uint8_t*)input, asset)) < 0)
+                goto fail;
+            avctx->profile = FF_PROFILE_DTS_HD_MA;
+            *sample_rate = xll.chset[0].freq << (xll.nfreqbands - 1);
+            *duration = xll.nframesamples << (xll.nfreqbands - 1);
+            avctx->bits_per_raw_sample = xll.chset[0].storage_bit_res;
+            avctx->bit_rate = 0;
+            if (avctx->bits_per_raw_sample == 24)
+                avctx->sample_fmt = AV_SAMPLE_FMT_S32P;
+            ch_mask = 0;
+            for (i = 0, c = xll.chset; i < xll.nactivechsets; i++, c++)
+                ch_mask |= c->ch_mask;
+        } else if (asset && (asset->extension_mask & DCA_EXSS_LBR)) {
+            // TODO: DTS-EXPRESS
+/*            DCAXllDecoder xll;
+            if ((ret = ff_dca_lbr_parse(&lbr, input, asset)) < 0)
+                goto fail;*/
+            avctx->profile = FF_PROFILE_DTS_EXPRESS;
+        } else if (asset && asset->extension_mask) {
+            avctx->profile = FF_PROFILE_DTS_HD_HRA;
+            if (asset->extension_mask & DCA_EXSS_X96 || x96_pos) {
+                *sample_rate <<= 1;
+                *duration <<= 1;
+            }
+            if (xch_pos)
+                ch_mask |= DCA_SPEAKER_MASK_Cs;
+            if (asset->extension_mask & DCA_EXSS_XXCH) {
+                if ((ret = init_get_bits8(&gb, input + asset->xxch_offset, asset->xxch_size)) < 0)
+                    return ret;
+                parse_xxch_frame(&gb, &ch_mask);
+            }
+        } else if (xch_pos || xxch_pos) {
+            if (xch_pos)
+                ch_mask |= DCA_SPEAKER_MASK_Cs;
+            if (xxch_pos) {
+                if ((ret = init_get_bits8(&gb, bebuf, buf_size)) < 0)
+                    goto fail;
+                gb.index = xxch_pos;
+                parse_xxch_frame(&gb, &ch_mask);
+            }
+            avctx->profile = FF_PROFILE_DTS_ES;
+            if (x96_pos) {
+                *sample_rate <<= 1;
+                *duration <<= 1;
+            }
+        } else if (x96_pos) {
+            avctx->profile = FF_PROFILE_DTS_96_24;
+            *sample_rate <<= 1;
+            *duration <<= 1;
+        } else {
+            avctx->profile = FF_PROFILE_DTS;
+        }
+
+fail:
+        av_freep(&bebuf);
+/*        if (ret < 0)
+            return ret; */
+    }
+
+    if (!avctx->channel_layout) {
+        avctx->channel_layout = get_channel_layout(ch_mask);
+        avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
+    }
+
     return 0;
 }
 
@@ -302,7 +572,7 @@
     }
 
     /* read the duration and sample rate from the frame header */
-    if (!dca_parse_params(pc1, buf, buf_size, &duration, &sample_rate)) {
+    if (!dca_parse_params(pc1, avctx, buf, buf_size, &duration, &sample_rate)) {
         if (!avctx->sample_rate)
             avctx->sample_rate = sample_rate;
         s->duration = av_rescale(duration, avctx->sample_rate, sample_rate);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dca_xll.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_xll.c
--- FFmpeg-Plex-Transcoder/libavcodec/dca_xll.c	2017-05-16 15:47:03.786792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dca_xll.c	2017-05-04 13:47:00.000000000 +0300
@@ -902,7 +902,7 @@
 
 static int parse_sub_headers(DCAXllDecoder *s, DCAExssAsset *asset)
 {
-    DCAContext *dca = s->avctx->priv_data;
+    DCAContext *dca = s->avctx ? s->avctx->priv_data : NULL;
     DCAXllChSet *c;
     int i, ret;
 
@@ -932,7 +932,7 @@
     }
 
     // Determine number of active channel sets to decode
-    switch (dca->request_channel_layout) {
+    switch (dca ? dca->request_channel_layout : 0) {
     case DCA_SPEAKER_LAYOUT_STEREO:
         s->nactivechsets = 1;
         break;
@@ -1175,6 +1175,7 @@
     return ret;
 }
 
+#if 0
 static void undo_down_mix(DCAXllDecoder *s, DCAXllChSet *o, int band)
 {
     int i, j, k, nchannels = 0, *coeff_ptr = o->dmix_coeff;
@@ -1467,6 +1468,7 @@
 
     return 0;
 }
+#endif
 
 av_cold void ff_dca_xll_flush(DCAXllDecoder *s)
 {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/decode.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/decode.c
--- FFmpeg-Plex-Transcoder/libavcodec/decode.c	2017-05-16 15:47:03.794792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/decode.c	2017-05-04 13:47:00.000000000 +0300
@@ -338,6 +338,12 @@
                     guess_correct_pts(avctx, frame->pts, frame->pkt_dts));
             }
         }
+
+        if (avctx->field_order == AV_FIELD_UNKNOWN &&
+            avctx->codec_type == AVMEDIA_TYPE_VIDEO &&
+            frame->interlaced_frame) {
+            avctx->field_order = (frame->top_field_first ? AV_FIELD_TT : AV_FIELD_BB);
+        }
         return ret;
     }
 
@@ -461,6 +467,10 @@
                                                guess_correct_pts(avctx,
                                                                  picture->pts,
                                                                  picture->pkt_dts));
+            if (avctx->field_order == AV_FIELD_UNKNOWN &&
+                picture->interlaced_frame) {
+                avctx->field_order = (picture->top_field_first ? AV_FIELD_TT : AV_FIELD_BB);
+            }
         } else
             av_frame_unref(picture);
     } else
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dvdsubdec.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dvdsubdec.c
--- FFmpeg-Plex-Transcoder/libavcodec/dvdsubdec.c	2017-05-16 15:47:03.806792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dvdsubdec.c	2017-05-04 13:47:00.000000000 +0300
@@ -588,6 +588,15 @@
         return appended ? 0 : append_to_cached_buf(avctx, buf, buf_size);
     }
 
+    // PLEX
+    // Some VOBSUB streams inside MKVs don't contain start/end times in the
+    // VOBSUB sense, instead relying on the PTS and duration from the MKV block.
+
+    if (sub->start_display_time >= sub->end_display_time && avpkt->duration > 0)
+        sub->end_display_time = sub->start_display_time + avpkt->duration;
+
+    // PLEX
+
     if (is_menu < 0) {
     no_subtitle:
         reset_rects(sub);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/dv_profile.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/dv_profile.c
--- FFmpeg-Plex-Transcoder/libavcodec/dv_profile.c	2017-05-16 15:47:03.802792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/dv_profile.c	2017-05-04 13:47:00.000000000 +0300
@@ -29,6 +29,9 @@
 #include "dv_profile.h"
 #include "dv_profile_internal.h"
 
+#undef CONFIG_DVPROFILE
+#define CONFIG_DVPROFILE 1
+
 #if CONFIG_DVPROFILE
 
 static const uint8_t dv_audio_shuffle525[10][9] = {
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: eae.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: framedrop_bsf.c
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/h264_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/h264_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/h264_parser.c	2017-05-16 15:47:03.842792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/h264_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -544,6 +544,10 @@
                 p->last_frame_num = p->poc.frame_num;
             }
 
+            //PLEX
+            ff_set_sar(avctx, sps->sar);
+            //PLEX
+
             av_freep(&nal.rbsp_buffer);
             return 0; /* no need to evaluate the rest */
         }
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/h264_ps.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/h264_ps.c
--- FFmpeg-Plex-Transcoder/libavcodec/h264_ps.c	2017-05-16 15:47:03.842792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/h264_ps.c	2017-05-04 13:47:00.000000000 +0300
@@ -423,6 +423,7 @@
         if (ret < 0)
             goto fail;
         sps->scaling_matrix_present |= ret;
+        avctx->scaling_matrix_present |= sps->scaling_matrix_present; //PLEX
     } else {
         sps->chroma_format_idc = 1;
         sps->bit_depth_luma    = 8;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/internal.h /home/klogg/Downloads/ffmpeg-plex/libavcodec/internal.h
--- FFmpeg-Plex-Transcoder/libavcodec/internal.h	2017-05-16 15:47:03.870792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/internal.h	2017-05-04 13:47:00.000000000 +0300
@@ -348,6 +348,10 @@
 
 int ff_side_data_set_encoder_stats(AVPacket *pkt, int quality, int64_t *error, int error_count, int pict_type);
 
+void ff_avcodec_scan_new_things(void);
+
+void ff_set_hwaccel_next(AVHWAccel *(*new_hook)(const struct AVHWAccel *hwaccel));
+
 /**
  * Check AVFrame for A53 side data and allocate and fill SEI message with A53 info
  *
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/Makefile /home/klogg/Downloads/ffmpeg-plex/libavcodec/Makefile
--- FFmpeg-Plex-Transcoder/libavcodec/Makefile	2017-05-16 16:04:37.738792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/Makefile	2017-05-04 13:47:00.000000000 +0300
@@ -2,6 +2,8 @@
 
 NAME = avcodec
 
+COMPONENTTYPES = encoder decoder parser
+
 HEADERS = avcodec.h                                                     \
           avdct.h                                                       \
           avfft.h                                                       \
@@ -102,6 +104,7 @@
 OBJS-$(CONFIG_MDCT)                    += mdct_fixed.o mdct_float.o mdct_fixed_32.o
 OBJS-$(CONFIG_ME_CMP)                  += me_cmp.o
 OBJS-$(CONFIG_MEDIACODEC)              += mediacodecdec_common.o mediacodec_surface.o mediacodec_wrapper.o mediacodec_sw_buffer.o
+OBJS-$(CONFIG_MEDIACODECNDK)           += mediacodecndk.o
 OBJS-$(CONFIG_MPEG_ER)                 += mpeg_er.o
 OBJS-$(CONFIG_MPEGAUDIO)               += mpegaudio.o
 OBJS-$(CONFIG_MPEGAUDIODSP)            += mpegaudiodsp.o                \
@@ -160,6 +163,7 @@
                                           aacenc_pred.o \
                                           psymodel.o mpeg4audio.o kbdwin.o cbrt_data.o
 OBJS-$(CONFIG_AASC_DECODER)            += aasc.o msrledec.o
+OBJS-$(CONFIG_MF)                      += mf.o mf_utils.o mpeg4audio.o
 OBJS-$(CONFIG_AC3_DECODER)             += ac3dec_float.o ac3dec_data.o ac3.o kbdwin.o
 OBJS-$(CONFIG_AC3_FIXED_DECODER)       += ac3dec_fixed.o ac3dec_data.o ac3.o kbdwin.o
 OBJS-$(CONFIG_AC3_ENCODER)             += ac3enc_float.o ac3enc.o ac3tab.o \
@@ -275,6 +279,7 @@
 OBJS-$(CONFIG_EAC3_DECODER)            += eac3_data.o
 OBJS-$(CONFIG_EAC3_ENCODER)            += eac3enc.o eac3_data.o
 OBJS-$(CONFIG_EACMV_DECODER)           += eacmv.o
+OBJS-$(CONFIG_EAE)                     += eae.o
 OBJS-$(CONFIG_EAMAD_DECODER)           += eamad.o eaidct.o mpeg12.o \
                                           mpeg12data.o
 OBJS-$(CONFIG_EATGQ_DECODER)           += eatgq.o eaidct.o
@@ -326,6 +331,8 @@
                                           h264_slice.o h264data.o
 OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuvid.o
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
+OBJS-$(CONFIG_H264_MEDIACODECNDK_DECODER) += mediacodecndkdec.o
+OBJS-$(CONFIG_H264_MEDIACODECNDK_ENCODER) += mediacodecndkenc.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
 OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc_h264.o
@@ -342,6 +349,7 @@
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o hevc_data.o
 OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuvid.o
+OBJS-$(CONFIG_HEVC_MEDIACODECNDK_DECODER) += mediacodecndkdec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc_hevc.o
 OBJS-$(CONFIG_NVENC_HEVC_ENCODER)      += nvenc_hevc.o
@@ -418,6 +426,7 @@
 OBJS-$(CONFIG_MPEGVIDEO_DECODER)       += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
+OBJS-$(CONFIG_MPEG2_MEDIACODECNDK_DECODER) += mediacodecndkdec.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec_other.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -429,11 +438,11 @@
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
 OBJS-$(CONFIG_MSA1_DECODER)            += mss3.o
-OBJS-$(CONFIG_MSMPEG4V1_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V2_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
+OBJS-$(CONFIG_MSMPEG4V1_DECODER)       += msmpeg4dec.o wmv2dec.o msmpeg4.o vc1data.o msmpeg4data.o intrax8.o intrax8dsp.o wmv2dsp.o
+OBJS-$(CONFIG_MSMPEG4V2_DECODER)       += msmpeg4dec.o wmv2dec.o msmpeg4.o vc1data.o msmpeg4data.o intrax8.o intrax8dsp.o wmv2dsp.o
 OBJS-$(CONFIG_MSMPEG4V2_ENCODER)       += msmpeg4enc.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V3_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V3_ENCODER)       += msmpeg4enc.o msmpeg4.o msmpeg4data.o
+OBJS-$(CONFIG_MSMPEG4V3_DECODER)       += msmpeg4dec.o wmv2dec.o msmpeg4.o vc1data.o msmpeg4data.o intrax8.o intrax8dsp.o wmv2dsp.o
+OBJS-$(CONFIG_MSMPEG4V3_ENCODER)       += msmpeg4enc.o msmpeg4.o vc1data.o msmpeg4data.o
 OBJS-$(CONFIG_MSRLE_DECODER)           += msrle.o msrledec.o
 OBJS-$(CONFIG_MSS1_DECODER)            += mss1.o mss12.o
 OBJS-$(CONFIG_MSS2_DECODER)            += mss2.o mss12.o mss2dsp.o wmv2data.o
@@ -592,7 +601,7 @@
 OBJS-$(CONFIG_VBLE_DECODER)            += vble.o
 OBJS-$(CONFIG_VC1_DECODER)             += vc1dec.o vc1_block.o vc1_loopfilter.o \
                                           vc1_mc.o vc1_pred.o vc1.o vc1data.o \
-                                          msmpeg4dec.o msmpeg4.o msmpeg4data.o \
+                                          msmpeg4dec.o wmv2dec.o msmpeg4.o msmpeg4data.o \
                                           wmv2dsp.o wmv2data.o
 OBJS-$(CONFIG_VC1_CUVID_DECODER)       += cuvid.o
 OBJS-$(CONFIG_VC1_MMAL_DECODER)        += mmaldec.o
@@ -637,10 +646,10 @@
 OBJS-$(CONFIG_WMAVOICE_DECODER)        += wmavoice.o \
                                           celp_filters.o \
                                           acelp_vectors.o acelp_filters.o
-OBJS-$(CONFIG_WMV1_DECODER)            += msmpeg4dec.o msmpeg4.o msmpeg4data.o
+OBJS-$(CONFIG_WMV1_DECODER)            += msmpeg4dec.o wmv2dec.o msmpeg4.o vc1data.o msmpeg4data.o intrax8.o intrax8dsp.o wmv2dsp.o
 OBJS-$(CONFIG_WMV1_ENCODER)            += msmpeg4enc.o
 OBJS-$(CONFIG_WMV2_DECODER)            += wmv2dec.o wmv2.o wmv2data.o \
-                                          msmpeg4dec.o msmpeg4.o msmpeg4data.o
+                                          msmpeg4dec.o wmv2dec.o msmpeg4.o vc1data.o msmpeg4data.o
 OBJS-$(CONFIG_WMV2_ENCODER)            += wmv2enc.o wmv2.o wmv2data.o \
                                           msmpeg4.o msmpeg4enc.o msmpeg4data.o
 OBJS-$(CONFIG_WNV1_DECODER)            += wnv1.o
@@ -924,16 +933,16 @@
 # parsers
 OBJS-$(CONFIG_AAC_LATM_PARSER)         += latm_parser.o
 OBJS-$(CONFIG_AAC_PARSER)              += aac_parser.o aac_ac3_parser.o \
-                                          aacadtsdec.o mpeg4audio.o
+                                          aacadtsdec.o mpeg4audio.o aactab.o
 OBJS-$(CONFIG_AC3_PARSER)              += ac3_parser.o ac3tab.o \
                                           aac_ac3_parser.o
 OBJS-$(CONFIG_ADX_PARSER)              += adx_parser.o adx.o
 OBJS-$(CONFIG_BMP_PARSER)              += bmp_parser.o
 OBJS-$(CONFIG_CAVSVIDEO_PARSER)        += cavs_parser.o
 OBJS-$(CONFIG_COOK_PARSER)             += cook_parser.o
-OBJS-$(CONFIG_DCA_PARSER)              += dca_parser.o dca_exss.o dca.o
+OBJS-$(CONFIG_DCA_PARSER)              += dca_parser.o dca_exss.o dca.o dca_xll.o dcadata.o dcadec.o
 OBJS-$(CONFIG_DIRAC_PARSER)            += dirac_parser.o
-OBJS-$(CONFIG_DNXHD_PARSER)            += dnxhd_parser.o
+OBJS-$(CONFIG_DNXHD_PARSER)            += dnxhd_parser.o dnxhddata.o
 OBJS-$(CONFIG_DPX_PARSER)              += dpx_parser.o
 OBJS-$(CONFIG_DVAUDIO_PARSER)          += dvaudio_parser.o
 OBJS-$(CONFIG_DVBSUB_PARSER)           += dvbsub_parser.o
@@ -976,9 +985,11 @@
 OBJS-$(CONFIG_CHOMP_BSF)                  += chomp_bsf.o
 OBJS-$(CONFIG_DUMP_EXTRADATA_BSF)         += dump_extradata_bsf.o
 OBJS-$(CONFIG_DCA_CORE_BSF)               += dca_core_bsf.o
+OBJS-$(CONFIG_FRAMEDROP_BSF)              += framedrop_bsf.o
 OBJS-$(CONFIG_EXTRACT_EXTRADATA_BSF)      += extract_extradata_bsf.o    \
                                              h2645_parse.o
 OBJS-$(CONFIG_H264_MP4TOANNEXB_BSF)       += h264_mp4toannexb_bsf.o
+OBJS-$(CONFIG_H264_PLEX_BSF)              += h264_plex_bsf.o
 OBJS-$(CONFIG_HEVC_MP4TOANNEXB_BSF)       += hevc_mp4toannexb_bsf.o
 OBJS-$(CONFIG_IMX_DUMP_HEADER_BSF)        += imx_dump_header_bsf.o
 OBJS-$(CONFIG_MJPEG2JPEG_BSF)             += mjpeg2jpeg_bsf.o
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/me_cmp.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/me_cmp.c
--- FFmpeg-Plex-Transcoder/libavcodec/me_cmp.c	2017-05-16 15:47:03.894792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/me_cmp.c	2017-05-04 13:47:00.000000000 +0300
@@ -1009,6 +1009,7 @@
 av_cold void ff_me_cmp_init(MECmpContext *c, AVCodecContext *avctx)
 {
     ff_check_alignment();
+    ff_me_cmp_init_static();
 
     c->sum_abs_dctelem = sum_abs_dctelem_c;
 
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mediacodecndk.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mediacodecndkdec.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mediacodecndkenc.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mediacodecndk.h
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mf.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mf_utils.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: mf_utils.h
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/mpegaudio_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegaudio_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/mpegaudio_parser.c	2017-05-16 15:47:03.950792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegaudio_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -84,7 +84,9 @@
                     if (s->header_count > header_threshold) {
                         avctx->sample_rate= sr;
                         avctx->channels   = channels;
+                        avctx->channel_layout = channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;
                         s1->duration      = frame_size;
+                        avctx->frame_size = frame_size;
                         avctx->codec_id   = codec_id;
                         if (s->no_bitrate || !avctx->bit_rate) {
                             s->no_bitrate = 1;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/mpegvideo_enc.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideo_enc.c
--- FFmpeg-Plex-Transcoder/libavcodec/mpegvideo_enc.c	2017-05-16 15:47:03.958792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideo_enc.c	2017-05-04 13:47:00.000000000 +0300
@@ -291,6 +291,7 @@
     AVCPBProperties *cpb_props;
     int i, ret, format_supported;
 
+    ff_me_cmp_init_static();
     mpv_encode_defaults(s);
 
     switch (avctx->codec_id) {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/mpegvideoencdsp.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideoencdsp.c
--- FFmpeg-Plex-Transcoder/libavcodec/mpegvideoencdsp.c	2017-05-16 15:47:03.958792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideoencdsp.c	2017-05-04 13:47:00.000000000 +0300
@@ -232,6 +232,8 @@
 av_cold void ff_mpegvideoencdsp_init(MpegvideoEncDSPContext *c,
                                      AVCodecContext *avctx)
 {
+    ff_me_cmp_init_static();
+
     c->try_8x8basis = try_8x8basis_c;
     c->add_8x8basis = add_8x8basis_c;
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/mpegvideo_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideo_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/mpegvideo_parser.c	2017-05-16 15:47:03.958792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/mpegvideo_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -29,6 +29,10 @@
     AVRational frame_rate;
     int progressive_sequence;
     int width, height;
+    //PLEX
+    int ps_width, ps_height;
+    int aspect_ratio_info;
+    //PLEX
 };
 
 
@@ -68,6 +72,7 @@
             if (bytes_left >= 7) {
                 pc->width  = (buf[0] << 4) | (buf[1] >> 4);
                 pc->height = ((buf[1] & 0x0f) << 8) | buf[2];
+                pc->aspect_ratio_info = buf[3] >> 4;
                 if(!avctx->width || !avctx->height || !avctx->coded_width || !avctx->coded_height){
                     set_dim_ret = ff_set_dimensions(avctx, pc->width, pc->height);
                     did_set_size=1;
@@ -112,6 +117,17 @@
                         avctx->ticks_per_frame = 2;
                     }
                     break;
+                //PLEX
+                case 0x2: /* sequence display extension */
+                    {
+                        const uint8_t *seqbuf = buf + 1;
+                        if (buf[0] & 0x01)
+                            seqbuf += 3;
+                        pc->ps_width = ((seqbuf[0] << 6) | (seqbuf[1] >> 2)) * 16;
+                        pc->ps_height = (((seqbuf[1] & 0x01 << 13)) | (seqbuf[2] << 5) | (seqbuf[3] >> 3)) * 16;
+                    }
+                    break;
+                //PLEX
                 case 0x8: /* picture coding extension */
                     if (bytes_left >= 5) {
                         top_field_first = buf[3] & (1 << 7);
@@ -174,6 +190,47 @@
         s->coded_height = FFALIGN(pc->height, 16);
     }
 
+    //PLEX: copied from mpeg12dec.c
+    if (pc->aspect_ratio_info) {
+        if (avctx->codec_id == AV_CODEC_ID_MPEG1VIDEO) {
+            // MPEG-1 aspect
+            avctx->sample_aspect_ratio = av_d2q(1.0 / ff_mpeg1_aspect[pc->aspect_ratio_info], 255);
+        } else if (pc->aspect_ratio_info > 1) { // MPEG-2
+            // MPEG-2 aspect
+            AVRational dar =
+                av_mul_q(av_div_q(ff_mpeg2_aspect[pc->aspect_ratio_info],
+                                  (AVRational) { pc->ps_width,
+                                                 pc->ps_height }),
+                         (AVRational) { s->width, s->height });
+
+            /* We ignore the spec here and guess a bit as reality does not
+             * match the spec, see for example res_change_ffmpeg_aspect.ts
+             * and sequence-display-aspect.mpg.
+             * issue1613, 621, 562 */
+            if ((pc->ps_width == 0) || (pc->ps_height == 0) ||
+                (av_cmp_q(dar, (AVRational) { 4, 3 }) &&
+                 av_cmp_q(dar, (AVRational) { 16, 9 }))) {
+                avctx->sample_aspect_ratio =
+                    av_div_q(ff_mpeg2_aspect[pc->aspect_ratio_info],
+                             (AVRational) { s->width, s->height });
+            } else {
+                avctx->sample_aspect_ratio =
+                    av_div_q(ff_mpeg2_aspect[pc->aspect_ratio_info],
+                             (AVRational) { pc->ps_width, pc->ps_height });
+// issue1613 4/3 16/9 -> 16/9
+// res_change_ffmpeg_aspect.ts 4/3 225/44 ->4/3
+// widescreen-issue562.mpg 4/3 16/9 -> 16/9
+//                s->avctx->sample_aspect_ratio = av_mul_q(s->avctx->sample_aspect_ratio, (AVRational) {s->width, s->height});
+                ff_dlog(avctx, "aspect A %d/%d\n",
+                        ff_mpeg2_aspect[pc->aspect_ratio_info].num,
+                        ff_mpeg2_aspect[pc->aspect_ratio_info].den);
+                ff_dlog(avctx, "aspect B %d/%d\n", avctx->sample_aspect_ratio.num,
+                        avctx->sample_aspect_ratio.den);
+            }
+        } // MPEG-2
+    }
+    //PLEX
+
 #if FF_API_AVCTX_TIMEBASE
     if (avctx->framerate.num)
         avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/parser.c	2017-05-16 15:47:03.982792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -35,11 +35,13 @@
 
 AVCodecParser *av_parser_next(const AVCodecParser *p)
 {
-    if (p)
+    if (p) {
         return p->next;
-    else
+    } else {
+        ff_avcodec_scan_new_things();
         return av_first_parser;
 }
+}
 
 void av_register_codec_parser(AVCodecParser *parser)
 {
@@ -57,6 +59,8 @@
     if (codec_id == AV_CODEC_ID_NONE)
         return NULL;
 
+    ff_avcodec_scan_new_things();
+
     for (parser = av_first_parser; parser; parser = parser->next) {
         if (parser->codec_ids[0] == codec_id ||
             parser->codec_ids[1] == codec_id ||
@@ -185,6 +189,12 @@
 #define FILL(name) if(s->name > 0 && avctx->name <= 0) avctx->name = s->name
     if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
         FILL(field_order);
+//PLEX
+        FILL(width);
+        FILL(height);
+        FILL(coded_width);
+        FILL(coded_height);
+//PLEX
     }
 
     /* update the file pointer */
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/pthread_frame.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/pthread_frame.c
--- FFmpeg-Plex-Transcoder/libavcodec/pthread_frame.c	2017-05-16 15:47:03.994792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/pthread_frame.c	2017-05-04 13:47:00.000000000 +0300
@@ -757,6 +757,8 @@
         return AVERROR(ENOMEM);
     }
 
+    avctx->thread_safe_callbacks = 1;
+
     pthread_mutex_init(&fctx->buffer_mutex, NULL);
     pthread_mutex_init(&fctx->hwaccel_mutex, NULL);
     pthread_mutex_init(&fctx->async_mutex, NULL);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/qsv.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/qsv.c
--- FFmpeg-Plex-Transcoder/libavcodec/qsv.c	2017-05-16 15:47:04.002792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/qsv.c	2017-05-04 13:47:00.000000000 +0300
@@ -277,7 +277,7 @@
         desc = "unknown";
     }
 
-    av_log(avctx, AV_LOG_VERBOSE,
+    av_log(avctx, AV_LOG_INFO,
            "Initialized an internal MFX session using %s implementation\n",
            desc);
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/utils.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/utils.c
--- FFmpeg-Plex-Transcoder/libavcodec/utils.c	2017-05-16 15:47:33.758792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/utils.c	2017-05-04 13:47:00.000000000 +0300
@@ -43,6 +43,7 @@
 #include "libavutil/samplefmt.h"
 #include "libavutil/dict.h"
 #include "libavutil/thread.h"
+#include "libavutil/extlib.h"
 #include "avcodec.h"
 #include "libavutil/opt.h"
 #include "me_cmp.h"
@@ -147,11 +148,13 @@
 
 AVCodec *av_codec_next(const AVCodec *c)
 {
-    if (c)
+    if (c) {
         return c->next;
-    else
+    } else {
+        ff_avcodec_scan_new_things();
         return first_avcodec;
 }
+}
 
 static av_cold void avcodec_init(void)
 {
@@ -179,6 +182,10 @@
 {
     AVCodec **p;
     avcodec_init();
+
+    if (codec->probe && codec->probe(codec) < 0)
+        return;
+
     p = last_avcodec;
     codec->next = NULL;
 
@@ -1206,20 +1213,23 @@
 
 static AVCodec *find_encdec(enum AVCodecID id, int encoder)
 {
-    AVCodec *p, *experimental = NULL;
-    p = first_avcodec;
+    AVCodec *p, *experimental = NULL, *fallback = NULL;
+    const AVCodecDescriptor *codec_desc = avcodec_descriptor_get(id);
+    p = av_codec_next(NULL);
     id= remap_deprecated_codec_id(id);
     while (p) {
         if ((encoder ? av_codec_is_encoder(p) : av_codec_is_decoder(p)) &&
             p->id == id) {
             if (p->capabilities & AV_CODEC_CAP_EXPERIMENTAL && !experimental) {
                 experimental = p;
-            } else
+            } else if (codec_desc && strcmp(codec_desc->name, p->name) == 0) {
                 return p;
+            } else if (!fallback)
+                fallback = p;
         }
         p = p->next;
     }
-    return experimental;
+    return fallback ? fallback : experimental;
 }
 
 AVCodec *avcodec_find_encoder(enum AVCodecID id)
@@ -1232,7 +1242,7 @@
     AVCodec *p;
     if (!name)
         return NULL;
-    p = first_avcodec;
+    p = av_codec_next(NULL);
     while (p) {
         if (av_codec_is_encoder(p) && strcmp(name, p->name) == 0)
             return p;
@@ -1251,7 +1261,7 @@
     AVCodec *p;
     if (!name)
         return NULL;
-    p = first_avcodec;
+    p = av_codec_next(NULL);
     while (p) {
         if (av_codec_is_decoder(p) && strcmp(name, p->name) == 0)
             return p;
@@ -1918,8 +1928,19 @@
     last_hwaccel = &hwaccel->next;
 }
 
+static AVHWAccel *(*hook_av_hwaccel_next)(const struct AVHWAccel *hwaccel) = NULL;
+
+void ff_set_hwaccel_next(AVHWAccel *(*new_hook)(const struct AVHWAccel *hwaccel))
+{
+    hook_av_hwaccel_next = new_hook;
+}
+
 AVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel)
 {
+    if (hook_av_hwaccel_next)
+        return hook_av_hwaccel_next(hwaccel);
+    if (!hwaccel)
+        ff_avcodec_scan_new_things();
     return hwaccel ? hwaccel->next : first_hwaccel;
 }
 
Only in /home/klogg/Downloads/ffmpeg-plex/libavcodec: vaapi.c
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/vc1.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/vc1.c
--- FFmpeg-Plex-Transcoder/libavcodec/vc1.c	2017-05-16 15:47:04.062792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/vc1.c	2017-05-04 13:47:00.000000000 +0300
@@ -1695,7 +1695,9 @@
     v->pq      = -1;
     v->mvrange = 0; /* 7.1.1.18, p80 */
 
+#if CONFIG_VC1_DECODER
     ff_vc1dsp_init(&v->vc1dsp);
+#endif
 
     return 0;
 }
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/vc1_parser.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/vc1_parser.c
--- FFmpeg-Plex-Transcoder/libavcodec/vc1_parser.c	2017-05-16 15:47:04.066792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/vc1_parser.c	2017-05-04 13:47:00.000000000 +0300
@@ -30,6 +30,7 @@
 #include "vc1.h"
 #include "get_bits.h"
 #include "internal.h"
+#include "startcode.h"
 
 /** The maximum number of bytes of a sequence, entry point or
  *  frame header whose values we pay any attention to */
@@ -185,7 +186,7 @@
         if (unesc_index >= UNESCAPED_THRESHOLD && !start_code_found) {
             while (i < buf_size) {
                 if (search_state == NO_MATCH) {
-                    i += vpc->v.vc1dsp.startcode_find_candidate(buf + i, buf_size - i);
+                    i += ff_startcode_find_candidate_c(buf + i, buf_size - i);
                     if (i < buf_size) {
                         search_state = ONE_ZERO;
                     }
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/webvttenc.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/webvttenc.c
--- FFmpeg-Plex-Transcoder/libavcodec/webvttenc.c	2017-05-16 15:47:04.090792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/webvttenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -112,7 +112,12 @@
 static void webvtt_text_cb(void *priv, const char *text, int len)
 {
     WebVTTContext *s = priv;
-    av_bprint_append_data(&s->buffer, text, len);
+    char *buf = av_strndup(text, len);
+    if (!buf)
+        return;
+
+    av_bprint_escape(&s->buffer, buf, NULL, AV_ESCAPE_MODE_XML, 0);
+    av_free(buf);
 }
 
 static void webvtt_new_line_cb(void *priv, int forced)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavcodec/wmv2dec.c /home/klogg/Downloads/ffmpeg-plex/libavcodec/wmv2dec.c
--- FFmpeg-Plex-Transcoder/libavcodec/wmv2dec.c	2017-05-16 15:47:04.098792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavcodec/wmv2dec.c	2017-05-04 13:47:00.000000000 +0300
@@ -455,6 +455,7 @@
     return 0;
 }
 
+#if CONFIG_WMV2_DECODER
 static av_cold int wmv2_decode_init(AVCodecContext *avctx)
 {
     Wmv2Context *const w = avctx->priv_data;
@@ -495,3 +496,4 @@
     .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
 };
+#endif
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavfilter/allfilters.c /home/klogg/Downloads/ffmpeg-plex/libavfilter/allfilters.c
--- FFmpeg-Plex-Transcoder/libavfilter/allfilters.c	2017-05-16 15:47:04.166792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavfilter/allfilters.c	2017-05-04 13:47:00.000000000 +0300
@@ -132,6 +132,10 @@
 
     REGISTER_FILTER(ANULLSINK,      anullsink,      asink);
 
+    // PLEX
+    REGISTER_FILTER(INLINEASS,      inlineass,      vf);
+    // PLEX
+
     REGISTER_FILTER(ALPHAEXTRACT,   alphaextract,   vf);
     REGISTER_FILTER(ALPHAMERGE,     alphamerge,     vf);
     REGISTER_FILTER(ASS,            ass,            vf);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavfilter/Makefile /home/klogg/Downloads/ffmpeg-plex/libavfilter/Makefile
--- FFmpeg-Plex-Transcoder/libavfilter/Makefile	2017-05-16 15:47:04.150792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavfilter/Makefile	2017-05-04 13:47:00.000000000 +0300
@@ -338,6 +338,8 @@
 
 OBJS-$(CONFIG_NULLSINK_FILTER)               += vsink_nullsink.o
 
+OBJS-$(CONFIG_INLINEASS_FILTER)              += vf_inlineass.o
+
 # multimedia filters
 OBJS-$(CONFIG_ABITSCOPE_FILTER)              += avf_abitscope.o
 OBJS-$(CONFIG_ADRAWGRAPH_FILTER)             += f_drawgraph.o
Only in /home/klogg/Downloads/ffmpeg-plex/libavfilter: vf_inlineass.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavfilter: vf_inlineass.h
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavfilter/vf_scale.c /home/klogg/Downloads/ffmpeg-plex/libavfilter/vf_scale.c
--- FFmpeg-Plex-Transcoder/libavfilter/vf_scale.c	2017-05-16 15:47:04.210792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavfilter/vf_scale.c	2017-05-04 13:47:00.000000000 +0300
@@ -239,8 +239,16 @@
     /* Note that force_original_aspect_ratio may overwrite the previous set
      * dimensions so that it is not divisible by the set factors anymore. */
     if (scale->force_original_aspect_ratio) {
-        int tmp_w = av_rescale(h, inlink->w, inlink->h);
-        int tmp_h = av_rescale(w, inlink->h, inlink->w);
+//PLEX: Use the DAR instead of the raw pixel ratio
+        int tmp_w, tmp_h;
+        if (inlink->sample_aspect_ratio.num && inlink->sample_aspect_ratio.den) {
+            tmp_w = av_rescale(h, inlink->w * inlink->sample_aspect_ratio.num, inlink->h * inlink->sample_aspect_ratio.den);
+            tmp_h = av_rescale(w, inlink->h * inlink->sample_aspect_ratio.den, inlink->w * inlink->sample_aspect_ratio.num);
+        } else {
+            tmp_w = av_rescale(h, inlink->w, inlink->h);
+            tmp_h = av_rescale(w, inlink->h, inlink->w);
+        }
+//PLEX
 
         if (scale->force_original_aspect_ratio == 1) {
              w = FFMIN(tmp_w, w);
@@ -249,6 +257,10 @@
              w = FFMAX(tmp_w, w);
              h = FFMAX(tmp_h, h);
         }
+        //PLEX
+        w &= ~3;
+        h &= ~3;
+        //PLEX
     }
 
     if (w > INT_MAX || h > INT_MAX ||
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/dashenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/dashenc.c
--- FFmpeg-Plex-Transcoder/libavformat/dashenc.c	2017-05-16 15:47:04.242792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/dashenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -83,6 +83,7 @@
     int window_size;
     int extra_window_size;
     int min_seg_duration;
+    int64_t time_delta; //PLEX
     int remove_at_exit;
     int use_template;
     int use_timeline;
@@ -98,6 +99,9 @@
     const char *media_seg_name;
     AVRational min_frame_rate, max_frame_rate;
     int ambiguous_frame_rate;
+//PLEX
+    int skip_to_segment;
+//PLEX
 } DASHContext;
 
 static int dash_write(void *opaque, uint8_t *buf, int buf_size)
@@ -668,7 +672,13 @@
             return ret;
         os->init_start_pos = 0;
 
+//PLEX
+        if (c->skip_to_segment > 1)
+            av_dict_set(&opts, "movflags", "frag_custom+dash+delay_moov+frag_discont", 0);
+        else
         av_dict_set(&opts, "movflags", "frag_custom+dash+delay_moov", 0);
+//PLEX
+
         if ((ret = avformat_init_output(ctx, &opts)) < 0)
             return ret;
         os->ctx_inited = 1;
@@ -677,6 +687,11 @@
 
         av_log(s, AV_LOG_VERBOSE, "Representation %d init segment will be written to: %s\n", i, filename);
 
+//PLEX
+        if (c->skip_to_segment > 1)
+            av_opt_set_int(os->ctx, "fragments", c->skip_to_segment, AV_OPT_SEARCH_CHILDREN);
+//PLEX
+
         s->streams[i]->time_base = st->time_base;
         // If the muxer wants to shift timestamps, request to have them shifted
         // already before being handed to this muxer, so we don't have mismatches
@@ -701,7 +716,7 @@
         os->first_pts = AV_NOPTS_VALUE;
         os->max_pts = AV_NOPTS_VALUE;
         os->last_dts = AV_NOPTS_VALUE;
-        os->segment_index = 1;
+        os->segment_index = c->skip_to_segment; //PLEX
     }
 
     if (!c->has_video && c->min_seg_duration <= 0) {
@@ -922,7 +937,7 @@
     DASHContext *c = s->priv_data;
     AVStream *st = s->streams[pkt->stream_index];
     OutputStream *os = &c->streams[pkt->stream_index];
-    int64_t seg_end_duration = (os->segment_index) * (int64_t) c->min_seg_duration;
+    int64_t seg_end_duration = (os->segment_index - c->skip_to_segment + 1) * (int64_t) c->min_seg_duration; //PLEX
     int ret;
 
     ret = update_stream_extradata(s, os, st->codecpar);
@@ -953,7 +968,7 @@
     if ((!c->has_video || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) &&
         pkt->flags & AV_PKT_FLAG_KEY && os->packets_written &&
         av_compare_ts(pkt->pts - os->first_pts, st->time_base,
-                      seg_end_duration, AV_TIME_BASE_Q) >= 0) {
+                      seg_end_duration - c->time_delta, AV_TIME_BASE_Q) >= 0) { //PLEX
         int64_t prev_duration = c->last_duration;
 
         c->last_duration = av_rescale_q(pkt->pts - os->start_pts,
@@ -1056,6 +1071,7 @@
     { "window_size", "number of segments kept in the manifest", OFFSET(window_size), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, E },
     { "extra_window_size", "number of segments kept outside of the manifest before removing from disk", OFFSET(extra_window_size), AV_OPT_TYPE_INT, { .i64 = 5 }, 0, INT_MAX, E },
     { "min_seg_duration", "minimum segment duration (in microseconds)", OFFSET(min_seg_duration), AV_OPT_TYPE_INT64, { .i64 = 5000000 }, 0, INT_MAX, E },
+    { "time_delta", "set approximation value used for the segment times", OFFSET(time_delta), AV_OPT_TYPE_DURATION, { .i64 = 0 }, 0, 0, E }, //PLEX
     { "remove_at_exit", "remove all segments when finished", OFFSET(remove_at_exit), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, E },
     { "use_template", "Use SegmentTemplate instead of SegmentList", OFFSET(use_template), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, E },
     { "use_timeline", "Use SegmentTimeline in SegmentTemplate", OFFSET(use_timeline), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, E },
@@ -1063,6 +1079,9 @@
     { "single_file_name", "DASH-templated name to be used for baseURL. Implies storing all segments in one file, accessed using byte ranges", OFFSET(single_file_name), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, E },
     { "init_seg_name", "DASH-templated name to used for the initialization segment", OFFSET(init_seg_name), AV_OPT_TYPE_STRING, {.str = "init-stream$RepresentationID$.m4s"}, 0, 0, E },
     { "media_seg_name", "DASH-templated name to used for the media segments", OFFSET(media_seg_name), AV_OPT_TYPE_STRING, {.str = "chunk-stream$RepresentationID$-$Number%05d$.m4s"}, 0, 0, E },
+//PLEX
+    { "skip_to_segment", "first segment number to actually write", OFFSET(skip_to_segment), AV_OPT_TYPE_INT, { .i64 = 1 }, 1, INT_MAX, E },
+//PLEX
     { NULL },
 };
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/hls.c /home/klogg/Downloads/ffmpeg-plex/libavformat/hls.c
--- FFmpeg-Plex-Transcoder/libavformat/hls.c	2017-05-16 15:47:04.258792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/hls.c	2017-05-04 13:47:00.000000000 +0300
@@ -1543,6 +1543,12 @@
 
     st->internal->need_context_update = 1;
 
+    // PLEX: properly probe frame_size field for mp2 if no probe decoder available (and probably mp1/m3).
+    if (st->codecpar->codec_id == AV_CODEC_ID_MP1 ||
+        st->codecpar->codec_id == AV_CODEC_ID_MP2 ||
+        st->codecpar->codec_id == AV_CODEC_ID_MP3)
+        st->need_parsing = AVSTREAM_PARSE_HEADERS;
+
     return 0;
 }
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/librtmp.c /home/klogg/Downloads/ffmpeg-plex/libavformat/librtmp.c
--- FFmpeg-Plex-Transcoder/libavformat/librtmp.c	2017-05-16 15:47:04.266792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/librtmp.c	2017-05-04 13:47:00.000000000 +0300
@@ -231,6 +231,8 @@
     if (flags & AVIO_FLAG_WRITE)
         RTMP_EnableWrite(r);
 
+    RTMP_SetBufferMS(r, 10 * 60 * 60 * 1000); //PLEX: 10 hours default
+
     if (!RTMP_Connect(r, NULL) || !RTMP_ConnectStream(r, 0)) {
         rc = AVERROR_UNKNOWN;
         goto fail;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/matroskadec.c /home/klogg/Downloads/ffmpeg-plex/libavformat/matroskadec.c
--- FFmpeg-Plex-Transcoder/libavformat/matroskadec.c	2017-05-16 15:47:33.762792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/matroskadec.c	2017-05-04 13:47:00.000000000 +0300
@@ -2155,6 +2155,14 @@
             av_freep(&key_id_base64);
         }
 
+        //PLEX
+        if (encodings_list->nb_elem == 1) {
+            av_dict_set_int(&st->metadata, "encoding_type", encodings[0].type, 0);
+            if (encodings[0].type == 0)
+              av_dict_set_int(&st->metadata, "compression_algo", encodings[0].compression.algo, 0);
+        }
+        //PLEX
+
         if (!strcmp(track->codec_id, "V_MS/VFW/FOURCC") &&
              track->codec_priv.size >= 40               &&
             track->codec_priv.data) {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/matroskaenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/matroskaenc.c
--- FFmpeg-Plex-Transcoder/libavformat/matroskaenc.c	2017-05-16 15:47:04.270792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/matroskaenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -21,6 +21,10 @@
 
 #include <stdint.h>
 
+//PLEX
+#include <stdlib.h>
+//PLEX
+
 #include "avc.h"
 #include "hevc.h"
 #include "avformat.h"
@@ -1906,14 +1910,14 @@
     // reserve space for the duration
     mkv->duration = 0;
     mkv->duration_offset = avio_tell(pb);
-    if (!mkv->is_live) {
+    if (!mkv->is_live || 1) { // PLEX: short-circuit
         int64_t metadata_duration = get_metadata_duration(s);
 
         if (s->duration > 0) {
             int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);
             put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);
             av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration);
-        } else if (metadata_duration > 0) {
+        } else if (metadata_duration > 0 && !(s->flags & AVFMT_FLAG_BITEXACT)) {
             int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);
             put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);
             av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration);
@@ -2268,6 +2272,13 @@
     int64_t relative_packet_pos;
     int dash_tracknum = mkv->is_dash ? mkv->dash_track_number : pkt->stream_index + 1;
 
+    //PLEX
+    if (ts == AV_NOPTS_VALUE && !mkv->tracks[pkt->stream_index].write_dts) {
+        mkv->tracks[pkt->stream_index].write_dts = 1;
+        ts = pkt->dts;
+    }
+    //PLEX
+
     if (ts == AV_NOPTS_VALUE) {
         av_log(s, AV_LOG_ERROR, "Can't write packet with unknown timestamp\n");
         return AVERROR(EINVAL);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/mov.c /home/klogg/Downloads/ffmpeg-plex/libavformat/mov.c
--- FFmpeg-Plex-Transcoder/libavformat/mov.c	2017-05-16 15:47:33.762792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/mov.c	2017-05-04 13:47:00.000000000 +0300
@@ -3177,7 +3177,7 @@
             curr_cts = current->timestamp + msc->dts_shift;
 
             if (ctts_data_old && ctts_index_old < ctts_count_old) {
-                av_log(mov->fc, AV_LOG_DEBUG, "shifted frame pts, curr_cts: %"PRId64" @ %"PRId64", ctts: %d, ctts_count: %"PRId64"\n",
+                av_log(mov->fc, AV_LOG_TRACE, "shifted frame pts, curr_cts: %"PRId64" @ %"PRId64", ctts: %d, ctts_count: %"PRId64"\n",
                        curr_cts, ctts_index_old, ctts_data_old[ctts_index_old].duration, ctts_count_old);
                 curr_cts += ctts_data_old[ctts_index_old].duration;
                 ctts_sample_old++;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/movenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/movenc.c
--- FFmpeg-Plex-Transcoder/libavformat/movenc.c	2017-05-16 16:04:37.742792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/movenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -94,6 +94,9 @@
     { "encryption_kid", "The media encryption key identifier (hex)", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },
     { "use_stream_ids_as_track_ids", "use stream ids as track ids", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},
     { "write_tmcd", "force or disable writing tmcd", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},
+//PLEX
+    { "mov_res", "Override resolution of video", offsetof(MOVMuxContext, video_width), AV_OPT_TYPE_IMAGE_SIZE, .flags = AV_OPT_FLAG_ENCODING_PARAM },
+//PLEX
     { NULL },
 };
 
@@ -473,7 +476,7 @@
         return AVERROR(EINVAL);
 
     info = track->eac3_priv;
-    size = 2 + 4 * (info->num_ind_sub + 1);
+    size = 2 + 5 * (info->num_ind_sub + 1);
     buf = av_malloc(size);
     if (!buf) {
         size = AVERROR(ENOMEM);
@@ -1897,7 +1900,7 @@
         avio_wb32(pb, 0); /* Reserved */
         avio_wb32(pb, 0); /* Reserved */
     }
-    avio_wb16(pb, track->par->width); /* Video width */
+    avio_wb16(pb, mov->video_width ? mov->video_width : track->par->width); /* Video width */
     avio_wb16(pb, track->height); /* Video height */
     avio_wb32(pb, 0x00480000); /* Horizontal resolution 72dpi */
     avio_wb32(pb, 0x00480000); /* Vertical resolution 72dpi */
@@ -2737,15 +2740,15 @@
                track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {
         int64_t track_width_1616;
         if (track->mode == MODE_MOV) {
-            track_width_1616 = track->par->width * 0x10000ULL;
+            track_width_1616 = (mov->video_width ? mov->video_width : track->par->width) * 0x10000ULL;
         } else {
             track_width_1616 = av_rescale(st->sample_aspect_ratio.num,
-                                                  track->par->width * 0x10000LL,
+                                                  (mov->video_width ? mov->video_width : track->par->width) * 0x10000LL,
                                                   st->sample_aspect_ratio.den);
             if (!track_width_1616 ||
                 track->height != track->par->height ||
                 track_width_1616 > UINT32_MAX)
-                track_width_1616 = track->par->width * 0x10000ULL;
+                track_width_1616 = (mov->video_width ? mov->video_width : track->par->width) * 0x10000ULL;
         }
         if (track_width_1616 > UINT32_MAX) {
             av_log(mov->fc, AV_LOG_WARNING, "track width is too large\n");
@@ -5255,7 +5258,7 @@
 
     if (par->codec_id == AV_CODEC_ID_VC1) {
         mov_parse_vc1_frame(pkt, trk);
-    } else if (pkt->flags & AV_PKT_FLAG_KEY) {
+    } else if (pkt->flags & AV_PKT_FLAG_KEY && par->codec_type != AVMEDIA_TYPE_SUBTITLE) {
         if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&
             trk->entry > 0) { // force sync sample for the first key frame
             mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);
@@ -5965,6 +5968,18 @@
                        "WARNING codec timebase is very high. If duration is too long,\n"
                        "file may not be playable by quicktime. Specify a shorter timebase\n"
                        "or choose different container.\n");
+
+            // PLEX
+            // Why just warn when you can fix? It should be safe to adjust the
+            // timescale here. Apple things, like QuickTime and iOS, seem to use
+            // a 32 bit value for PTS, so a really large timescale means that
+            // we may quickly run into trouble. This way we should be fine for
+            // content shorter than 12 hours.
+            //
+            if (track->timescale > 100000)
+                track->timescale = 100000;
+            // PLEX
+
             if (track->mode == MODE_MOV &&
                 track->par->codec_id == AV_CODEC_ID_RAWVIDEO &&
                 track->tag == MKTAG('r','a','w',' ')) {
@@ -6047,7 +6062,7 @@
             track->timescale = MOV_TIMESCALE;
         }
         if (!track->height)
-            track->height = st->codecpar->height;
+            track->height = mov->video_height ? mov->video_height : st->codecpar->height;
         /* The ism specific timescale isn't mandatory, but is assumed by
          * some tools, such as mp4split. */
         if (mov->mode == MODE_ISM)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/movenc.h /home/klogg/Downloads/ffmpeg-plex/libavformat/movenc.h
--- FFmpeg-Plex-Transcoder/libavformat/movenc.h	2017-05-16 15:47:04.278792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/movenc.h	2017-05-04 13:47:00.000000000 +0300
@@ -220,6 +220,9 @@
     int use_stream_ids_as_track_ids;
     int track_ids_ok;
     int write_tmcd;
+//PLEX
+    int video_width, video_height;
+//PLEX
 } MOVMuxContext;
 
 #define FF_MOV_FLAG_RTP_HINT              (1 <<  0)
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/mpegtsenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/mpegtsenc.c
--- FFmpeg-Plex-Transcoder/libavformat/mpegtsenc.c	2017-05-16 15:47:04.282792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/mpegtsenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -115,6 +115,7 @@
     int64_t last_sdt_ts;
 
     int omit_video_pes_length;
+    int include_sdt; // PLEX
 } MpegTSWrite;
 
 /* a PES packet header is generated every DEFAULT_PES_HEADER_FREQ packets */
@@ -674,6 +675,14 @@
     uint8_t data[SECTION_LENGTH], *q, *desc_list_len_ptr, *desc_len_ptr;
     int i, running_status, free_ca_mode, val;
 
+    // PLEX
+    // The Roku gets confused by SDT packets in a way that often leads to firmware
+    // crashes. There's never anything interesting in the SDT anyway, so we
+    // default to omitting it.
+    if (!ts->include_sdt && 0)
+        return;
+    // PLEX
+
     q = data;
     put16(&q, ts->onid);
     *q++ = 0xff;
@@ -1548,12 +1557,26 @@
             dts += delay;
     }
 
+    //PLEX
+    if (ts_st->first_pts_check && pts == AV_NOPTS_VALUE)
+        pts = dts;
+    //PLEX
+
     if (ts_st->first_pts_check && pts == AV_NOPTS_VALUE) {
         av_log(s, AV_LOG_ERROR, "first pts value must be set\n");
         return AVERROR_INVALIDDATA;
     }
     ts_st->first_pts_check = 0;
 
+    //PLEX
+    if ((dts < 0 && dts != AV_NOPTS_VALUE) || (pts < 0 && pts != AV_NOPTS_VALUE)) {
+        // We can't write packets with negative DTS/PTS, but AAC in particular is
+        // likely to create a couple because of its encoder delay.
+        av_log(s, AV_LOG_WARNING, "Ignoring packet with negative DTS (%lld) PTS (%lld) for codec %d\n", dts, pts, st->codec->codec_id);
+        return 0;
+    }
+    //PLEX
+
     if (st->codecpar->codec_id == AV_CODEC_ID_H264) {
         const uint8_t *p = buf, *buf_end = p + size;
         uint32_t state = -1;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/mux.c /home/klogg/Downloads/ffmpeg-plex/libavformat/mux.c
--- FFmpeg-Plex-Transcoder/libavformat/mux.c	2017-05-16 15:47:04.286792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/mux.c	2017-05-04 13:47:00.000000000 +0300
@@ -865,12 +865,27 @@
     return 0;
 }
 
+static int do_new_extradata_copy(AVCodecParameters *par, AVPacket *pkt) {
+    int side_size;
+    uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);
+    if (side) {
+        uint8_t *new_extra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (!new_extra)
+            return AVERROR(ENOMEM);
+        memcpy(new_extra, side, side_size);
+        av_free(par->extradata);
+        par->extradata = new_extra;
+        par->extradata_size = side_size;
+    }
+    return 1;
+}
+
 static int do_packet_auto_bsf(AVFormatContext *s, AVPacket *pkt) {
     AVStream *st = s->streams[pkt->stream_index];
     int i, ret;
 
     if (!(s->flags & AVFMT_FLAG_AUTO_BSF))
-        return 1;
+        return do_new_extradata_copy(st->codecpar, pkt);
 
     if (s->oformat->check_bitstream) {
         if (!st->internal->bitstream_checked) {
@@ -881,6 +896,9 @@
         }
     }
 
+    if (!st->internal->nb_bsfcs)
+        return do_new_extradata_copy(st->codecpar, pkt);
+
 #if FF_API_LAVF_MERGE_SD
 FF_DISABLE_DEPRECATION_WARNINGS
     if (st->internal->nb_bsfcs) {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/os_support.h /home/klogg/Downloads/ffmpeg-plex/libavformat/os_support.h
--- FFmpeg-Plex-Transcoder/libavformat/os_support.h	2017-05-16 15:47:04.294792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/os_support.h	2017-05-04 13:47:00.000000000 +0300
@@ -29,8 +29,11 @@
 
 #include "config.h"
 
+#include <stdlib.h>
 #include <sys/stat.h>
 
+#include "libavutil/mem.h"
+
 #ifdef _WIN32
 #if HAVE_DIRECT_H
 #include <direct.h>
@@ -158,14 +161,14 @@
 #define USE_MOVEFILEEXA
 #endif
 
-#define DEF_FS_FUNCTION(name, wfunc, afunc)               \
-static inline int win32_##name(const char *filename_utf8) \
+#define DEF_FS_FUNCTION3(rettype, retfail, name, wfunc, afunc) \
+static inline rettype win32_##name(const char *filename_utf8) \
 {                                                         \
     wchar_t *filename_w;                                  \
-    int ret;                                              \
+    rettype ret;                                          \
                                                           \
     if (utf8towchar(filename_utf8, &filename_w))          \
-        return -1;                                        \
+        return retfail;                                   \
     if (!filename_w)                                      \
         goto fallback;                                    \
                                                           \
@@ -178,6 +181,8 @@
     return afunc(filename_utf8);                          \
 }
 
+#define DEF_FS_FUNCTION(name, wfunc, afunc) DEF_FS_FUNCTION3(int, -1, name, wfunc, afunc)
+
 DEF_FS_FUNCTION(unlink, _wunlink, _unlink)
 DEF_FS_FUNCTION(mkdir,  _wmkdir,  _mkdir)
 DEF_FS_FUNCTION(rmdir,  _wrmdir , _rmdir)
@@ -222,7 +227,7 @@
         goto fallback;
     }
 
-    ret = MoveFileExW(src_w, dest_w, MOVEFILE_REPLACE_EXISTING);
+    ret = !MoveFileExW(src_w, dest_w, MOVEFILE_REPLACE_EXISTING);
     av_free(src_w);
     av_free(dest_w);
     // Lacking proper mapping from GetLastError() error codes to errno codes
@@ -256,6 +261,32 @@
 #define unlink      win32_unlink
 #define access      win32_access
 
+static inline char *ff_getenv(const char *name)
+{
+    size_t max = 32767; // documented maximum
+    wchar_t *wenv = av_mallocz_array(max + 1, sizeof(wchar_t));
+    wchar_t *wname;
+    char *env = NULL;
+    (void)utf8towchar(name, &wname);
+    if (!wenv || !wname)
+        goto done;
+    if (!GetEnvironmentVariableW(wname, wenv, max))
+        goto done;
+    (void)wchartoutf8(wenv, &env);
+done:
+    av_free(wenv);
+    av_free(wname);
+    return env;
+}
+
+#else
+
+static inline char *ff_getenv(const char *name)
+{
+    char *env = getenv(name);
+    return env ? av_strdup(env) : NULL;
+}
+
 #endif
 
 #endif /* AVFORMAT_OS_SUPPORT_H */
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/segment.c /home/klogg/Downloads/ffmpeg-plex/libavformat/segment.c
--- FFmpeg-Plex-Transcoder/libavformat/segment.c	2017-05-16 15:47:04.318792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/segment.c	2017-05-04 13:47:00.000000000 +0300
@@ -53,6 +53,9 @@
     char *filename;
     struct SegmentListEntry *next;
     int64_t last_duration;
+//PLEX
+    double end_audio_time, end_video_time;
+//PLEX
 } SegmentListEntry;
 
 typedef enum {
@@ -126,6 +129,9 @@
     SegmentListEntry cur_entry;
     SegmentListEntry *segment_list_entries;
     SegmentListEntry *segment_list_entries_end;
+
+    int segment_copyts;    ///< PLEX
+    int list_separate_times;    ///< PLEX
 } SegmentContext;
 
 static void print_csv_escaped_str(AVIOContext *ctx, const char *str)
@@ -223,6 +229,12 @@
              seg->entry_prefix ? seg->entry_prefix : "",
              av_basename(oc->filename));
 
+    // PLEX
+    // Write segment data to temp file, so we don't accidentally grab a partial segment.
+    if(!seg->list)
+      av_strlcatf(oc->filename, sizeof(oc->filename), ".tmp");
+    // PLEX
+
     return 0;
 }
 
@@ -308,6 +320,7 @@
 
 static void segment_list_print_entry(AVIOContext      *list_ioctx,
                                      ListType          list_type,
+                                     int               list_separate_times,
                                      const SegmentListEntry *list_entry,
                                      void *log_ctx)
 {
@@ -318,6 +331,9 @@
     case LIST_TYPE_CSV:
     case LIST_TYPE_EXT:
         print_csv_escaped_str(list_ioctx, list_entry->filename);
+        if (list_separate_times)
+            avio_printf(list_ioctx, ",%f,%f,%f,%f\n", list_entry->start_time, list_entry->end_time, list_entry->end_audio_time, list_entry->end_video_time);
+        else
         avio_printf(list_ioctx, ",%f,%f\n", list_entry->start_time, list_entry->end_time);
         break;
     case LIST_TYPE_M3U8:
@@ -392,14 +408,14 @@
             if ((ret = segment_list_open(s)) < 0)
                 goto end;
             for (entry = seg->segment_list_entries; entry; entry = entry->next)
-                segment_list_print_entry(seg->list_pb, seg->list_type, entry, s);
+                segment_list_print_entry(seg->list_pb, seg->list_type, seg->list_separate_times, entry, s);
             if (seg->list_type == LIST_TYPE_M3U8 && is_last)
                 avio_printf(seg->list_pb, "#EXT-X-ENDLIST\n");
             ff_format_io_close(s, &seg->list_pb);
             if (seg->use_rename)
                 ff_rename(seg->temp_list_filename, seg->list, s);
         } else {
-            segment_list_print_entry(seg->list_pb, seg->list_type, &seg->cur_entry, s);
+            segment_list_print_entry(seg->list_pb, seg->list_type, seg->list_separate_times, &seg->cur_entry, s);
             avio_flush(seg->list_pb);
         }
     }
@@ -434,6 +450,18 @@
 end:
     ff_format_io_close(oc, &oc->pb);
 
+    // PLEX
+
+    // Now rename the temporary file.
+    if (!seg->list) {
+        char* final_filename = av_strdup(oc->filename);
+        final_filename[strlen(final_filename)-4] = '\0';
+        rename(oc->filename, final_filename);
+        av_free(final_filename);
+    }
+
+    // PLEX
+
     return ret;
 }
 
@@ -656,6 +684,11 @@
         seg->individual_header_trailer = 0;
     }
 
+    //PLEX
+    if (seg->segment_copyts)
+        seg->segment_count = seg->segment_idx;
+    //PLEX
+
     if (seg->initial_offset > 0) {
         av_log(s, AV_LOG_WARNING, "NOTE: the option initial_offset is deprecated,"
                "you can use output_ts_offset instead of it\n");
@@ -905,6 +938,10 @@
         seg->cur_entry.start_time = (double)pkt->pts * av_q2d(st->time_base);
         seg->cur_entry.start_pts = av_rescale_q(pkt->pts, st->time_base, AV_TIME_BASE_Q);
         seg->cur_entry.end_time = seg->cur_entry.start_time;
+//PLEX
+        seg->cur_entry.end_audio_time = -1;
+        seg->cur_entry.end_video_time = -1;
+//PLEX
 
         if (seg->times || (!seg->frames && !seg->use_clocktime) && seg->write_empty)
             goto calc_times;
@@ -941,6 +978,18 @@
            av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &st->time_base),
            av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &st->time_base));
 
+//PLEX
+    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+    {
+        enum AVMediaType codec_type = st->codecpar->codec_type;
+        double end_time = pkt->pts + pkt->duration * av_q2d(st->time_base);
+
+        if (codec_type == AVMEDIA_TYPE_AUDIO)
+            seg->cur_entry.end_audio_time = FFMAX(seg->cur_entry.end_audio_time, end_time);
+        else if (codec_type == AVMEDIA_TYPE_VIDEO)
+            seg->cur_entry.end_video_time = FFMAX(seg->cur_entry.end_video_time, end_time);
+    }
+//PLEX
     ret = ff_write_chained(seg->avf, pkt->stream_index, pkt, s, seg->initial_offset || seg->reset_timestamps);
 
 fail:
@@ -1037,6 +1086,8 @@
     { "m3u8", "M3U8 format",     0, AV_OPT_TYPE_CONST, {.i64=LIST_TYPE_M3U8 }, INT_MIN, INT_MAX, E, "list_type" },
     { "hls", "Apple HTTP Live Streaming compatible", 0, AV_OPT_TYPE_CONST, {.i64=LIST_TYPE_M3U8 }, INT_MIN, INT_MAX, E, "list_type" },
 
+    { "segment_list_separate_stream_times", "adds additional fields in segment list for separate audio and video end times",   OFFSET(list_separate_times),    AV_OPT_TYPE_BOOL,   {.i64 = 0}, 0, 1, E}, //PLEX
+
     { "segment_atclocktime",      "set segment to be cut at clocktime",  OFFSET(use_clocktime), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, E},
     { "segment_clocktime_offset", "set segment clocktime offset",        OFFSET(clocktime_offset), AV_OPT_TYPE_DURATION, {.i64 = 0}, 0, 86400000000LL, E},
     { "segment_clocktime_wrap_duration", "set segment clocktime wrapping duration", OFFSET(clocktime_wrap_duration), AV_OPT_TYPE_DURATION, {.i64 = INT64_MAX}, 0, INT64_MAX, E},
@@ -1048,6 +1099,7 @@
     { "segment_list_entry_prefix", "set base url prefix for segments", OFFSET(entry_prefix), AV_OPT_TYPE_STRING,  {.str = NULL}, 0, 0, E },
     { "segment_start_number", "set the sequence number of the first segment", OFFSET(segment_idx), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, E },
     { "segment_wrap_number", "set the number of wrap before the first segment", OFFSET(segment_idx_wrap_nb), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, E },
+    { "segment_copyts",    "adjust timestamps for -copyts setting",      OFFSET(segment_copyts), AV_OPT_TYPE_BOOL,   {.i64 = 0}, 0, 1,       E }, //PLEX
     { "strftime",          "set filename expansion with strftime at segment creation", OFFSET(use_strftime), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, E },
     { "increment_tc", "increment timecode between each segment", OFFSET(increment_tc), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, E },
     { "break_non_keyframes", "allow breaking segments on non-keyframes", OFFSET(break_non_keyframes), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, E },
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/spdifenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/spdifenc.c
--- FFmpeg-Plex-Transcoder/libavformat/spdifenc.c	2017-05-16 15:47:04.322792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/spdifenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -118,7 +118,7 @@
     static const uint8_t eac3_repeat[4] = {6, 3, 2, 1};
     int repeat = 1;
 
-    if ((pkt->data[4] & 0xc0) != 0xc0) /* fscod */
+    if ((pkt->data[5] >> 3 >= 16) && (pkt->data[4] & 0xc0) != 0xc0) /* bsid, fscod */
         repeat = eac3_repeat[(pkt->data[4] & 0x30) >> 4]; /* numblkscod */
 
     ctx->hd_buf = av_fast_realloc(ctx->hd_buf, &ctx->hd_buf_size, ctx->hd_buf_filled + pkt->size);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/utils.c /home/klogg/Downloads/ffmpeg-plex/libavformat/utils.c
--- FFmpeg-Plex-Transcoder/libavformat/utils.c	2017-05-16 15:47:04.334792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/utils.c	2017-05-04 13:47:00.000000000 +0300
@@ -164,6 +164,7 @@
 
 static const AVCodec *find_decoder(AVFormatContext *s, const AVStream *st, enum AVCodecID codec_id)
 {
+    AVCodec *codec;
 #if FF_API_LAVF_AVCTX
 FF_DISABLE_DEPRECATION_WARNINGS
     if (st->codec->codec)
@@ -183,6 +184,9 @@
         break;
     }
 
+    if ((codec = avcodec_find_decoder_by_name(avcodec_get_name(codec_id))))
+        return codec;
+
     return avcodec_find_decoder(codec_id);
 }
 
@@ -198,7 +202,7 @@
 #endif
 
     codec = find_decoder(s, st, codec_id);
-    if (!codec)
+    if (!codec || strstr(codec->name, "_eae"))
         return NULL;
 
     if (codec->capabilities & AV_CODEC_CAP_AVOID_PROBING) {
@@ -210,6 +214,8 @@
                 return probe_codec;
             }
         }
+        // Trying a system decoder here will cause more trouble than it solves.
+        return NULL;
     }
 
     return codec;
@@ -506,7 +512,7 @@
     return 0;
 }
 
-
+attribute_align_arg
 int avformat_open_input(AVFormatContext **ps, const char *filename,
                         AVInputFormat *fmt, AVDictionary **options)
 {
@@ -1437,7 +1443,7 @@
         /* set the duration */
         out_pkt.duration = (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
         if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
-            if (st->internal->avctx->sample_rate > 0) {
+            if (st->internal->avctx->sample_rate > 0 && st->parser->duration >= 0) {
                 out_pkt.duration =
                     av_rescale_q_rnd(st->parser->duration,
                                      (AVRational) { 1, st->internal->avctx->sample_rate },
@@ -1462,6 +1468,11 @@
         if (st->parser->key_frame == -1 && st->parser->pict_type ==AV_PICTURE_TYPE_NONE && (pkt->flags&AV_PKT_FLAG_KEY))
             out_pkt.flags |= AV_PKT_FLAG_KEY;
 
+//PLEX
+        if (pkt->flags & AV_PKT_FLAG_DISCARD)
+            out_pkt.flags |= AV_PKT_FLAG_DISCARD;
+//PLEX
+
         compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);
 
         ret = add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
@@ -2914,8 +2925,8 @@
             FAIL("unspecified sample rate");
         if (!avctx->channels)
             FAIL("unspecified number of channels");
-        if (st->info->found_decoder >= 0 && !st->nb_decoded_frames && avctx->codec_id == AV_CODEC_ID_DTS)
-            FAIL("no decodable DTS frames");
+/*        if (st->info->found_decoder >= 0 && !st->nb_decoded_frames && avctx->codec_id == AV_CODEC_ID_DTS)
+            FAIL("no decodable DTS frames");*/ //PLEX
         break;
     case AVMEDIA_TYPE_VIDEO:
         if (!avctx->width)
@@ -2982,7 +2993,7 @@
     } else if (!st->info->found_decoder)
         st->info->found_decoder = 1;
 
-    if (st->info->found_decoder < 0) {
+    if (st->info->found_decoder < 0 || !avctx->codec) {
         ret = -1;
         goto fail;
     }
@@ -3491,7 +3502,7 @@
     return 0;
 }
 
-int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
+int attribute_align_arg avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
 {
     int i, count = 0, ret = 0, j;
     int64_t read_size;
@@ -3561,6 +3572,10 @@
                     st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
                 } else if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW) {
                     st->parser->flags |= PARSER_FLAG_USE_CODEC_TS;
+                } else if (st->need_parsing == AVSTREAM_PARSE_NONE &&
+                           st->parser->flags & PARSER_FLAG_ONCE) {
+                    st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;
+                    st->parser->flags |= PARSER_FLAG_SKIP;
                 }
             } else if (st->need_parsing) {
                 av_log(ic, AV_LOG_VERBOSE, "parser not found for codec "
@@ -4027,6 +4042,11 @@
         if (ret < 0)
             goto find_stream_info_err;
 
+//PLEX
+        st->codec->refs = st->internal->avctx->refs;
+        st->codec->scaling_matrix_present = st->internal->avctx->scaling_matrix_present;
+//PLEX
+
         // The old API (AVStream.codec) "requires" the resolution to be adjusted
         // by the lowres factor.
         if (av_codec_get_lowres(st->internal->avctx) && st->internal->avctx->width) {
@@ -4061,6 +4081,8 @@
     }
 
 find_stream_info_err:
+    // PLEX: do not discard/free info?? (see 416836c1fc36b15a2)
+#if 0
     for (i = 0; i < ic->nb_streams; i++) {
         st = ic->streams[i];
         if (st->info)
@@ -4069,6 +4091,7 @@
         av_bsf_free(&ic->streams[i]->internal->extract_extradata.bsf);
         av_packet_free(&ic->streams[i]->internal->extract_extradata.pkt);
     }
+#endif
     if (ic->pb)
         av_log(ic, AV_LOG_DEBUG, "After avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d frames:%d\n",
                avio_tell(ic->pb), ic->pb->bytes_read, ic->pb->seek_count, count);
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavformat/webvttenc.c /home/klogg/Downloads/ffmpeg-plex/libavformat/webvttenc.c
--- FFmpeg-Plex-Transcoder/libavformat/webvttenc.c	2017-05-16 15:47:04.338792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavformat/webvttenc.c	2017-05-04 13:47:00.000000000 +0300
@@ -26,6 +26,18 @@
 
 #include "avformat.h"
 #include "internal.h"
+//PLEX
+#include "libavutil/opt.h"
+#include <float.h>
+//PLEX
+
+//PLEX
+typedef struct {
+    const AVClass  *class;
+    float           sync_vtt;
+    int64_t         sync_mpeg;
+} WebVTTMuxContext;
+//PLEX
 
 static void webvtt_write_time(AVIOContext *pb, int64_t millisec)
 {
@@ -48,6 +60,7 @@
     AVStream     *s = ctx->streams[0];
     AVCodecParameters *par = ctx->streams[0]->codecpar;
     AVIOContext *pb = ctx->pb;
+    WebVTTMuxContext *priv = (WebVTTMuxContext*)ctx->priv_data; //PLEX
 
     if (ctx->nb_streams != 1 || par->codec_id != AV_CODEC_ID_WEBVTT) {
         av_log(ctx, AV_LOG_ERROR, "Exactly one WebVTT stream is needed.\n");
@@ -57,6 +70,11 @@
     avpriv_set_pts_info(s, 64, 1, 1000);
 
     avio_printf(pb, "WEBVTT\n");
+    //PLEX
+    avio_printf(pb, "X-TIMESTAMP-MAP=LOCAL:");
+    webvtt_write_time(pb, priv->sync_vtt * 1000);
+    avio_printf(pb, ",MPEGTS:%02"PRId64"\n", priv->sync_mpeg);
+    //PLEX
     avio_flush(pb);
 
     return 0;
@@ -94,11 +112,30 @@
     return 0;
 }
 
+//PLEX
+#define OFFSET(x) offsetof(WebVTTMuxContext, x)
+#define FLAGS AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    { "sync_vtt",  "Specifies a particular WebVTT timestamp for the sync header.", OFFSET(sync_vtt),  AV_OPT_TYPE_FLOAT, { .dbl = 0      }, 0, FLT_MAX,   FLAGS },
+    { "sync_mpeg", "Specifies a particular MPEGTS timestamp for the sync header.", OFFSET(sync_mpeg), AV_OPT_TYPE_INT64, { .i64 = 900000 }, 0, INT64_MAX, FLAGS },
+    { NULL },
+};
+
+static const AVClass webvtt_class = {
+    .class_name = "WebVTT muxer",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+//PLEX
+
 AVOutputFormat ff_webvtt_muxer = {
     .name              = "webvtt",
     .long_name         = NULL_IF_CONFIG_SMALL("WebVTT subtitle"),
     .extensions        = "vtt",
     .mime_type         = "text/vtt",
+    .priv_data_size    = sizeof(WebVTTMuxContext), //PLEX
+    .priv_class        = &webvtt_class, //PLEX
     .flags             = AVFMT_VARIABLE_FPS | AVFMT_TS_NONSTRICT,
     .subtitle_codec    = AV_CODEC_ID_WEBVTT,
     .write_header      = webvtt_write_header,
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/avstring.h /home/klogg/Downloads/ffmpeg-plex/libavutil/avstring.h
--- FFmpeg-Plex-Transcoder/libavutil/avstring.h	2017-05-16 15:47:04.354792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/avstring.h	2017-05-04 13:47:00.000000000 +0300
@@ -314,6 +314,8 @@
     AV_ESCAPE_MODE_AUTO,      ///< Use auto-selected escaping mode.
     AV_ESCAPE_MODE_BACKSLASH, ///< Use backslash escaping.
     AV_ESCAPE_MODE_QUOTE,     ///< Use single-quote escaping.
+    AV_ESCAPE_MODE_XML,       ///< Use XML ampersand-escaping; requires UTF-8 input.
+    AV_ESCAPE_MODE_URL,       ///< Use URL percent-escaping
 };
 
 /**
@@ -334,6 +336,33 @@
 #define AV_ESCAPE_FLAG_STRICT (1 << 1)
 
 /**
+ * In addition to the provided list, escape all characters outside the range of
+ * U+0020 to U+007E.
+ * This only applies to XML-escaping.
+ */
+#define AV_ESCAPE_FLAG_NON_ASCII (1 << 2)
+
+/**
+ * In addition to the provided list, escape single or double quotes.
+ * This only applies to XML-escaping.
+ */
+#define AV_ESCAPE_FLAG_ESCAPE_SINGLE_QUOTE (1 << 3)
+#define AV_ESCAPE_FLAG_ESCAPE_DOUBLE_QUOTE (1 << 4)
+
+/**
+ * Replace invalid UTF-8 characters with a U+FFFD REPLACEMENT CHARACTER, escaped
+ * if AV_ESCAPE_FLAG_NON_ASCII is set.
+ * This only applies to XML-escaping.
+ */
+#define AV_ESCAPE_FLAG_REPLACE_INVALID_SEQUENCES (1 << 5)
+
+/**
+ * Replace invalid UTF-8 characters with a '?', overriding the previous flag.
+ * This only applies to XML-escaping.
+ */
+#define AV_ESCAPE_FLAG_REPLACE_INVALID_ASCII (1 << 6)
+
+/**
  * Escape string in src, and put the escaped string in an allocated
  * string in *dst, which must be freed with av_free().
  *
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/bprint.c /home/klogg/Downloads/ffmpeg-plex/libavutil/bprint.c
--- FFmpeg-Plex-Transcoder/libavutil/bprint.c	2017-05-16 15:47:04.354792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/bprint.c	2017-05-04 13:47:00.000000000 +0300
@@ -271,19 +271,8 @@
         mode = AV_ESCAPE_MODE_BACKSLASH; /* TODO: implement a heuristic */
 
     switch (mode) {
-    case AV_ESCAPE_MODE_QUOTE:
-        /* enclose the string between '' */
-        av_bprint_chars(dstbuf, '\'', 1);
-        for (; *src; src++) {
-            if (*src == '\'')
-                av_bprintf(dstbuf, "'\\''");
-            else
-                av_bprint_chars(dstbuf, *src, 1);
-        }
-        av_bprint_chars(dstbuf, '\'', 1);
-        break;
-
     /* case AV_ESCAPE_MODE_BACKSLASH or unknown mode */
+    case AV_ESCAPE_MODE_BACKSLASH:
     default:
         /* \-escape characters */
         for (; *src; src++) {
@@ -301,5 +290,71 @@
             av_bprint_chars(dstbuf, *src, 1);
         }
         break;
+
+    case AV_ESCAPE_MODE_QUOTE:
+        /* enclose the string between '' */
+        av_bprint_chars(dstbuf, '\'', 1);
+        for (; *src; src++) {
+            if (*src == '\'')
+                av_bprintf(dstbuf, "'\\''");
+            else
+                av_bprint_chars(dstbuf, *src, 1);
+        }
+        av_bprint_chars(dstbuf, '\'', 1);
+        break;
+
+    case AV_ESCAPE_MODE_XML:
+        /* &;-escape characters */
+        while (*src) {
+            uint8_t tmp;
+            uint32_t cp;
+            const char *src1 = src;
+            GET_UTF8(cp, (uint8_t)*src++, goto err;);
+
+            if ((cp < 0xFF &&
+                 ((special_chars && strchr(special_chars, cp)) ||
+                  (flags & AV_ESCAPE_FLAG_WHITESPACE) && strchr(WHITESPACES, cp))) ||
+                (!(flags & AV_ESCAPE_FLAG_STRICT) &&
+                 (cp == '&' || cp == '<' || cp == '>')) ||
+                ((flags & AV_ESCAPE_FLAG_ESCAPE_SINGLE_QUOTE) && cp == '\'') ||
+                ((flags & AV_ESCAPE_FLAG_ESCAPE_DOUBLE_QUOTE) && cp == '"') ||
+                ((flags & AV_ESCAPE_FLAG_NON_ASCII) && (cp < 0x20 || cp > 0x7e))) {
+                switch (cp) {
+                case '&' : av_bprintf(dstbuf, "&amp;");  break;
+                case '<' : av_bprintf(dstbuf, "&lt;");   break;
+                case '>' : av_bprintf(dstbuf, "&gt;");   break;
+                case '"' : av_bprintf(dstbuf, "&quot;"); break;
+                case '\'': av_bprintf(dstbuf, "&apos;"); break;
+                default:   av_bprintf(dstbuf, "&#x%"PRIx32";", cp); break;
+                }
+            } else {
+                PUT_UTF8(cp, tmp, av_bprint_chars(dstbuf, tmp, 1);)
+            }
+            continue;
+        err:
+            if (flags & AV_ESCAPE_FLAG_REPLACE_INVALID_ASCII) {
+                av_bprint_chars(dstbuf, '?', 1);
+            } else if (flags & AV_ESCAPE_FLAG_REPLACE_INVALID_SEQUENCES) {
+                if (flags & AV_ESCAPE_FLAG_NON_ASCII)
+                    av_bprintf(dstbuf, "\xEF\xBF\xBD");
+                else
+                    av_bprintf(dstbuf, "&#xfffd;");
+            } else {
+                while (src1 < src)
+                    av_bprint_chars(dstbuf, *src1++, 1);
+            }
+        }
+        break;
+
+    case AV_ESCAPE_MODE_URL:
+        for (; *src; src++) {
+            int is_strictly_special = special_chars && strchr(special_chars, *src);
+            if (is_strictly_special ||
+                (!(flags & AV_ESCAPE_FLAG_STRICT) && !strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~", *src)))
+                av_bprintf(dstbuf, "%%%02X", *src);
+            else
+                av_bprint_chars(dstbuf, *src, 1);
+        }
+        break;
     }
 }
Only in /home/klogg/Downloads/ffmpeg-plex/libavutil: extlib.h
Only in /home/klogg/Downloads/ffmpeg-plex/libavutil: extlib_init.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavutil: extloader.c
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/hwcontext.c /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext.c
--- FFmpeg-Plex-Transcoder/libavutil/hwcontext.c	2017-05-16 15:47:04.362792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext.c	2017-05-04 13:47:00.000000000 +0300
@@ -44,6 +44,9 @@
 #if CONFIG_VDPAU
     &ff_hwcontext_type_vdpau,
 #endif
+#if CONFIG_MF
+    &ff_hwcontext_type_mf,
+#endif
     NULL,
 };
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/hwcontext.h /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext.h
--- FFmpeg-Plex-Transcoder/libavutil/hwcontext.h	2017-05-16 15:47:04.362792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext.h	2017-05-04 13:47:00.000000000 +0300
@@ -30,6 +30,7 @@
     AV_HWDEVICE_TYPE_VAAPI,
     AV_HWDEVICE_TYPE_DXVA2,
     AV_HWDEVICE_TYPE_QSV,
+    AV_HWDEVICE_TYPE_MF,
 };
 
 typedef struct AVHWDeviceInternal AVHWDeviceInternal;
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/hwcontext_internal.h /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext_internal.h
--- FFmpeg-Plex-Transcoder/libavutil/hwcontext_internal.h	2017-05-16 15:47:04.366792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext_internal.h	2017-05-04 13:47:00.000000000 +0300
@@ -144,5 +144,6 @@
 extern const HWContextType ff_hwcontext_type_qsv;
 extern const HWContextType ff_hwcontext_type_vaapi;
 extern const HWContextType ff_hwcontext_type_vdpau;
+extern const HWContextType ff_hwcontext_type_mf;
 
 #endif /* AVUTIL_HWCONTEXT_INTERNAL_H */
Only in /home/klogg/Downloads/ffmpeg-plex/libavutil: hwcontext_mf.c
Only in /home/klogg/Downloads/ffmpeg-plex/libavutil: hwcontext_mf.h
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/hwcontext_qsv.c /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext_qsv.c
--- FFmpeg-Plex-Transcoder/libavutil/hwcontext_qsv.c	2017-05-16 15:47:04.366792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/hwcontext_qsv.c	2017-05-04 13:47:00.000000000 +0300
@@ -847,7 +847,7 @@
 
     err = MFXInit(impl, &ver, &hwctx->session);
     if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Error initializing an MFX session\n");
+        av_log(ctx, AV_LOG_ERROR, "Error initializing an MFX session (error=%d)\n", err);
         return AVERROR_UNKNOWN;
     }
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/Makefile /home/klogg/Downloads/ffmpeg-plex/libavutil/Makefile
--- FFmpeg-Plex-Transcoder/libavutil/Makefile	2017-05-16 16:00:48.850792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/Makefile	2017-05-04 13:47:00.000000000 +0300
@@ -38,6 +38,7 @@
           hwcontext_qsv.h                                               \
           hwcontext_vaapi.h                                             \
           hwcontext_vdpau.h                                             \
+          hwcontext_mf.h                                                \
           imgutils.h                                                    \
           intfloat.h                                                    \
           intreadwrite.h                                                \
@@ -108,6 +109,7 @@
        downmix_info.o                                                   \
        error.o                                                          \
        eval.o                                                           \
+       extloader.o                                                      \
        fifo.o                                                           \
        file.o                                                           \
        file_open.o                                                      \
@@ -161,6 +163,7 @@
 OBJS-$(CONFIG_LZO)                      += lzo.o
 OBJS-$(CONFIG_OPENCL)                   += opencl.o opencl_internal.o
 OBJS-$(CONFIG_VAAPI)                    += hwcontext_vaapi.o
+OBJS-$(CONFIG_MF)                       += hwcontext_mf.o
 OBJS-$(CONFIG_VDPAU)                    += hwcontext_vdpau.o
 
 OBJS += $(COMPAT_OBJS:%=../compat/%)
@@ -173,6 +176,7 @@
 SKIPHEADERS-$(CONFIG_DXVA2)            += hwcontext_dxva2.h
 SKIPHEADERS-$(CONFIG_QSV)           += hwcontext_qsv.h
 SKIPHEADERS-$(CONFIG_VAAPI)            += hwcontext_vaapi.h
+SKIPHEADERS-$(CONFIG_MF)               += hwcontext_mf.h
 SKIPHEADERS-$(CONFIG_VDPAU)            += hwcontext_vdpau.h
 SKIPHEADERS-$(HAVE_ATOMICS_GCC)        += atomic_gcc.h
 SKIPHEADERS-$(HAVE_ATOMICS_SUNCC)      += atomic_suncc.h
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/pixdesc.c /home/klogg/Downloads/ffmpeg-plex/libavutil/pixdesc.c
--- FFmpeg-Plex-Transcoder/libavutil/pixdesc.c	2017-05-16 15:47:04.374792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/pixdesc.c	2017-05-04 13:47:00.000000000 +0300
@@ -2158,6 +2158,10 @@
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
+    [AV_PIX_FMT_MF] = {
+        .name = "mf",
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
 };
 #if FF_API_PLUS1_MINUS1
 FF_ENABLE_DEPRECATION_WARNINGS
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/pixfmt.h /home/klogg/Downloads/ffmpeg-plex/libavutil/pixfmt.h
--- FFmpeg-Plex-Transcoder/libavutil/pixfmt.h	2017-05-16 15:47:04.378792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/pixfmt.h	2017-05-04 13:47:00.000000000 +0300
@@ -314,6 +314,8 @@
     AV_PIX_FMT_P016LE, ///< like NV12, with 16bpp per component, little-endian
     AV_PIX_FMT_P016BE, ///< like NV12, with 16bpp per component, big-endian
 
+    AV_PIX_FMT_MF,          ///< hardware decoding though MediaFoundation (IMFSample)
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/version.h /home/klogg/Downloads/ffmpeg-plex/libavutil/version.h
--- FFmpeg-Plex-Transcoder/libavutil/version.h	2017-05-16 15:47:04.390792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/version.h	2017-05-04 13:47:00.000000000 +0300
@@ -79,7 +79,7 @@
  */
 
 #define LIBAVUTIL_VERSION_MAJOR  55
-#define LIBAVUTIL_VERSION_MINOR  61
+#define LIBAVUTIL_VERSION_MINOR  62
 #define LIBAVUTIL_VERSION_MICRO 100
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libavutil/wchar_filename.h /home/klogg/Downloads/ffmpeg-plex/libavutil/wchar_filename.h
--- FFmpeg-Plex-Transcoder/libavutil/wchar_filename.h	2017-05-16 15:47:04.390792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libavutil/wchar_filename.h	2017-05-04 13:47:00.000000000 +0300
@@ -40,6 +40,24 @@
     MultiByteToWideChar(CP_UTF8, 0, filename_utf8, -1, *filename_w, num_chars);
     return 0;
 }
+
+av_warn_unused_result
+static inline int wchartoutf8(const wchar_t *filename_w, char **filename_utf8)
+{
+    int num_chars;
+    num_chars = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, filename_w, -1, NULL, 0, NULL, NULL);
+    if (num_chars <= 0) {
+        *filename_utf8 = NULL;
+        return 0;
+    }
+    *filename_utf8 = av_mallocz(num_chars);
+    if (!*filename_utf8) {
+        errno = ENOMEM;
+        return -1;
+    }
+    WideCharToMultiByte(CP_UTF8, 0, filename_w, -1, *filename_utf8, num_chars, NULL, NULL);
+    return 0;
+}
 #endif
 
 #endif /* AVUTIL_WCHAR_FILENAME_H */
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/library.mak /home/klogg/Downloads/ffmpeg-plex/library.mak
--- FFmpeg-Plex-Transcoder/library.mak	2017-05-16 15:47:04.394792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/library.mak	2017-05-04 13:47:00.000000000 +0300
@@ -7,6 +7,46 @@
 
 INSTHEADERS := $(INSTHEADERS) $(HEADERS:%=$(SUBDIR)%)
 
+EXTLIBS := $(foreach type, $(COMPONENTTYPES), $(filter %$(type), $(EXTERNALS)))
+
+EXTFFLIBS := $(EXTFFLIBS) -l$(NAME)
+
+install-lib$(NAME)-components:
+
+ORIGNAME := $(NAME)
+
+NAME = $(EXTLIB)
+UPPERNAME = $(shell echo $(EXTLIB) | tr a-z A-Z)
+TYPE = $(notdir $(subst _,/,$(UPPERNAME)))
+define EXTRULE
+-include $(wildcard $(patsubst $(filter-out $(OBJS-$(NAME):%=$(SUBDIR)%), $(OBJS)), %.o, %.d) $(OBJS-$(NAME):%=$(SUBDIR)%-$(NAME).d) $(SUBDIR)$(NAME)-extlib_init.d)
+$(SUBDIR)$(NAME)-extlib_init.o: libavutil/extlib_init.c
+	$$(COMPILE_C) -DEXTLIBNAME=ff_$(NAME) -DBUILDING_EXTERNAL_$(TYPE) -DHAVE_AV_CONFIG_H -DFFLIB_$(ORIGNAME) -DEXTLIBHWACCELS="$(HWACCELS-$(NAME))" -DEXTLIBHWACCEL_PTRS="$(HWACCELS-$(NAME):%=&%)"
+$(SUBDIR)%.o-$(NAME).o: $(SUBDIR)%.c
+	$$(COMPILE_C) -DBUILDING_$(UPPERNAME)_EXTERNAL -DBUILDING_EXTERNAL -DHAVE_AV_CONFIG_H
+$(SUBDIR)%.o-$(NAME).o: $(SUBDIR)%.S
+	$$(COMPILE_S) -DBUILDING_$(UPPERNAME)_EXTERNAL -DBUILDING_EXTERNAL -DHAVE_AV_CONFIG_H
+$(SUBDIR)x86/%.o-$(NAME).o: $(SUBDIR)x86/%$(YASMD).asm
+	$$(DEPYASM) $$(YASMFLAGS) -I $$(<D)/ -M -o $$@ $$< > $$(@:.o=.d)
+	$$(YASM) $$(YASMFLAGS) -I $$(<D)/ -o $$@ $$<
+	-$$(if $$(ASMSTRIPFLAGS), $$(STRIP) $$(ASMSTRIPFLAGS) $$@)
+$(SUBDIR)lib$(NAME).ver:
+	$(Q)echo $(NAME)_1 "{ global: av_init_library; local: *; };" | $(VERSION_SCRIPT_POSTPROCESS_CMD) > $$@
+$(SUBDIR)$(SLIBNAME): $(filter-out $(OBJS-$(NAME):%=$(SUBDIR)%), $(OBJS)) $(OBJS-$(NAME):%=$(SUBDIR)%-$(NAME).o) $(SUBDIR)$(NAME)-extlib_init.o $(SUBDIR)lib$(NAME).ver $(FF_STATIC_DEP_LIBS)
+	$(SLIB_CREATE_DEF_CMD)
+	$$(LD) $(SHFLAGS) $(EXTLIBFLAGS) $(LDFLAGS) $(LDLIBFLAGS) $$(LD_O) $$(filter %.o,$$^) $(FF_STATIC_DEP_LIBS) $(EXTRALIBS)
+install-$(NAME): $(SUBDIR)$(SLIBNAME)
+	$(Q)mkdir -p "$(SHLIBDIR)/components/"
+	$$(INSTALL) -m 755 $$< "$(SHLIBDIR)/components/$(SLIBNAME)"
+	$$(STRIP) "$(SHLIBDIR)/components/$(SLIBNAME)"
+install-lib$(ORIGNAME)-components: install-$(NAME)
+all: $(SUBDIR)$(SLIBNAME)
+endef
+
+$(foreach EXTLIB, $(EXTLIBS), $(eval $(EXTRULE)))
+
+NAME := $(ORIGNAME)
+
 all-$(CONFIG_STATIC): $(SUBDIR)$(LIBNAME)
 all-$(CONFIG_SHARED): $(SUBDIR)$(SLIBNAME)
 
@@ -21,6 +61,8 @@
 
 install-headers: install-lib$(NAME)-headers install-lib$(NAME)-pkgconfig
 
+install-components: install-lib$(ORIGNAME)-components
+
 install-libs-$(CONFIG_STATIC): install-lib$(NAME)-static
 install-libs-$(CONFIG_SHARED): install-lib$(NAME)-shared
 
@@ -47,8 +89,8 @@
 endif
 
 clean::
-	$(RM) $(addprefix $(SUBDIR),$(CLEANFILES) $(CLEANSUFFIXES) $(LIBSUFFIXES)) \
-	    $(CLEANSUFFIXES:%=$(SUBDIR)$(ARCH)/%) $(CLEANSUFFIXES:%=$(SUBDIR)tests/%)
+	$$(call RM_SPLIT,$(addprefix $(SUBDIR),$(CLEANFILES) $(CLEANSUFFIXES) $(LIBSUFFIXES)) \
+	    $(CLEANSUFFIXES:%=$(SUBDIR)$(ARCH)/%) $(CLEANSUFFIXES:%=$(SUBDIR)tests/%))
  
 distclean:: clean
 	$(RM) $(DISTCLEANSUFFIXES:%=$(SUBDIR)%) $(DISTCLEANSUFFIXES:%=$(SUBDIR)$(ARCH)/%) \
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/libswscale/utils.c /home/klogg/Downloads/ffmpeg-plex/libswscale/utils.c
--- FFmpeg-Plex-Transcoder/libswscale/utils.c	2017-05-16 16:04:37.742792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/libswscale/utils.c	2017-05-04 13:47:00.000000000 +0300
@@ -1142,6 +1142,7 @@
     }
 }
 
+attribute_align_arg
 av_cold int sws_init_context(SwsContext *c, SwsFilter *srcFilter,
                              SwsFilter *dstFilter)
 {
diff -wru -x 'tests*' -x '\.*' FFmpeg-Plex-Transcoder/Makefile /home/klogg/Downloads/ffmpeg-plex/Makefile
--- FFmpeg-Plex-Transcoder/Makefile	2017-05-16 16:04:37.734792920 +0300
+++ /home/klogg/Downloads/ffmpeg-plex/Makefile	2017-05-04 13:47:00.000000000 +0300
@@ -29,7 +29,7 @@
 $(foreach prog,$(AVBASENAMES),$(eval OBJS-$(prog) += cmdutils.o))
 $(foreach prog,$(AVBASENAMES),$(eval OBJS-$(prog)-$(CONFIG_OPENCL) += cmdutils_opencl.o))
 
-OBJS-ffmpeg                   += ffmpeg_opt.o ffmpeg_filter.o
+OBJS-ffmpeg                   += ffmpeg_opt.o ffmpeg_filter.o plex.o
 OBJS-ffmpeg-$(CONFIG_VIDEOTOOLBOX) += ffmpeg_videotoolbox.o
 OBJS-ffmpeg-$(CONFIG_LIBMFX)  += ffmpeg_qsv.o
 OBJS-ffmpeg-$(CONFIG_VAAPI)   += ffmpeg_vaapi.o
@@ -39,6 +39,7 @@
 OBJS-ffmpeg-$(CONFIG_CUVID)   += ffmpeg_cuvid.o
 OBJS-ffmpeg-$(HAVE_DXVA2_LIB) += ffmpeg_dxva2.o
 OBJS-ffmpeg-$(HAVE_VDPAU_X11) += ffmpeg_vdpau.o
+OBJS-ffmpeg-$(CONFIG_MF)      += ffmpeg_mf.o
 OBJS-ffserver                 += ffserver_config.o
 
 TESTTOOLS   = audiogen videogen rotozoom tiny_psnr tiny_ssim base64 audiomatch
@@ -95,7 +96,7 @@
                ARMV5TE-OBJS ARMV6-OBJS ARMV8-OBJS VFP-OBJS NEON-OBJS     \
                ALTIVEC-OBJS VSX-OBJS MMX-OBJS YASM-OBJS                  \
                MIPSFPU-OBJS MIPSDSPR2-OBJS MIPSDSP-OBJS MSA-OBJS         \
-               MMI-OBJS OBJS SLIBOBJS HOSTOBJS TESTOBJS
+               MMI-OBJS OBJS SLIBOBJS HOSTOBJS TESTOBJS COMPONENTTYPES
 
 define RESET
 $(1) :=
Only in /home/klogg/Downloads/ffmpeg-plex/: plex.c
Only in /home/klogg/Downloads/ffmpeg-plex/: plex.h
